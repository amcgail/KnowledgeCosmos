/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/three-bvh-csg@0.0.17/src/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BufferAttribute as t,Vector3 as e,Ray as n,Vector2 as r,Vector4 as i,Mesh as o,Matrix4 as s,Line3 as a,Plane as c,Triangle as l,DoubleSide as u,Matrix3 as d,BufferGeometry as h,Group as g,Color as f,MeshPhongMaterial as p,MathUtils as m,LineSegments as y,LineBasicMaterial as b,InstancedMesh as w,SphereGeometry as x,MeshBasicMaterial as A}from"/npm/three@0.175.0/+esm";import{MeshBVH as v,ExtendedTriangle as S}from"/npm/three-mesh-bvh@0.9.0/+esm";const T=1e-6,M=Math.pow(10,-Math.log10(T)),B=5e-7*M;function z(t){return~~(t*M+B)}function E(t){return`${z(t.x)},${z(t.y)},${z(t.z)}`}function I(t){return`${z(t.x)},${z(t.y)},${z(t.z)},${z(t.w)}`}function C(t,e,n){n.direction.subVectors(e,t).normalize();const r=t.dot(n.direction);return n.origin.copy(t).addScaledVector(n.direction,-r),n}function _(){return"undefined"!=typeof SharedArrayBuffer}function G(t){if(t.buffer instanceof SharedArrayBuffer)return t;const e=t.constructor,n=t.buffer,r=new SharedArrayBuffer(n.byteLength),i=new Uint8Array(n);return new Uint8Array(r).set(i,0),new e(r)}function V(e,n){if(!e.index){const r=e.attributes.position.count,i=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(r,n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);e.setIndex(new t(i,1));for(let t=0;t<r;t++)i[t]=t}}function P(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}const j=new e;function k(t){return t%3}function X(t,e){return t.start-e.start}function D(t,e){return j.subVectors(e,t.origin).dot(t.direction)}const $=1e-5,W=1e-4;class N{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let r=1/0,i=null;for(let a=0,c=e.length;a<c;a++){const c=e[a];if(o(c,t)&&o(c,n))continue;const l=s(c,t),u=s(c,n),d=Math.min(l,u);d<r&&(r=d,i=c)}return i;function o(t,e){const n=t.origin.distanceTo(e.origin)>$;return t.direction.angleTo(e.direction)>W||n}function s(t,e){const n=t.origin.distanceTo(e.origin),r=t.direction.angleTo(e.direction);return n/$+r/W}}}const R=new e,F=new e,U=new n;function O(t,e,n){const r=t.attributes,i=t.index,o=r.position,s=new Map,a=new Map,c=Array.from(e),l=new N;for(let t=0,e=c.length;t<e;t++){const e=c[t],n=~~(e/3),r=k(e);let s,u=3*n+r,d=3*n+(r+1)%3;i&&(u=i.getX(u),d=i.getX(d)),R.fromBufferAttribute(o,u),F.fromBufferAttribute(o,d),C(R,F,U);let h=l.findClosestRay(U);null===h&&(h=U.clone(),l.addRay(h)),a.has(h)||a.set(h,{forward:[],reverse:[],ray:h}),s=a.get(h);let g=D(h,R),f=D(h,F);g>f&&([g,f]=[f,g]),U.direction.dot(h.direction)<0?s.reverse.push({start:g,end:f,index:e}):s.forward.push({start:g,end:f,index:e})}return a.forEach((({forward:t,reverse:e},r)=>{!function(t,e,n,r=1e-8){t.sort(X),e.sort(X);for(let r=0;r<t.length;r++){const i=t[r];for(let a=0;a<e.length;a++){const c=e[a];if(c.start>i.end);else{if(i.end<c.start||c.end<i.start)continue;if(i.start<=c.start&&i.end>=c.end)o(c.end,i.end)||t.splice(r+1,0,{start:c.end,end:i.end,index:i.index}),i.end=c.start,c.start=0,c.end=0;else if(i.start>=c.start&&i.end<=c.end)o(i.end,c.end)||e.splice(a+1,0,{start:i.end,end:c.end,index:c.index}),c.end=i.start,i.start=0,i.end=0;else if(i.start<=c.start&&i.end<=c.end){const t=i.end;i.end=c.start,c.start=t}else{if(!(i.start>=c.start&&i.end>=c.end))throw new Error;{const t=c.end;c.end=i.start,i.start=t}}}if(n.has(i.index)||n.set(i.index,[]),n.has(c.index)||n.set(c.index,[]),n.get(i.index).push(c.index),n.get(c.index).push(i.index),s(c)&&(e.splice(a,1),a--),s(i)){t.splice(r,1),r--;break}}}function i(t){for(let e=0;e<t.length;e++)s(t[e])&&(t.splice(e,1),e--)}function o(t,e){return Math.abs(e-t)<r}function s(t){return Math.abs(t.end-t.start)<r}i(t),i(e)}(t,e,s,n),0===t.length&&0===e.length&&a.delete(r)})),{disjointConnectivityMap:s,fragmentMap:a}}const L=new r,H=new e,q=new i,Y=["","",""];class Z{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[3*t+e];return-1===n?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[3*t+e];return-1===n?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=3*t+e,r=this.disjointConnections.get(n);return r?r.map((t=>~~(t/3))):[]}getDisjointSiblingEdgeIndices(t,e){const n=3*t+e,r=this.disjointConnections.get(n);return r?r.map((t=>t%3)):[]}isFullyConnected(){return 0===this.unmatchedEdges}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:r,degenerateEpsilon:i}=this,o=e?function(t){let e="";for(let r=0,i=c.length;r<i;r++){const i=a[c[r]];let o;switch(i.itemSize){case 1:o=z(i.getX(t));break;case 2:o=`${z((n=L.fromBufferAttribute(i,t)).x)},${z(n.y)}`;break;case 3:o=E(H.fromBufferAttribute(i,t));break;case 4:o=I(q.fromBufferAttribute(i,t))}""!==e&&(e+="|"),e+=o}var n;return e}:function(t){return H.fromBufferAttribute(u,t),E(H)},s=new Map,{attributes:a}=t,c=e?Object.keys(a):null,l=t.index,u=a.position;let d=P(t);const h=d;let g=0;n&&(g=t.drawRange.start,t.drawRange.count!==1/0&&(d=~~(t.drawRange.count/3)));let f=this.data;(!f||f.length<3*h)&&(f=new Int32Array(3*h)),f.fill(-1);let p=0,m=new Set;for(let t=g,e=3*d+g;t<e;t+=3){const e=t;for(let t=0;t<3;t++){let n=e+t;l&&(n=l.getX(n)),Y[t]=o(n)}for(let t=0;t<3;t++){const n=(t+1)%3,r=Y[t],i=Y[n],o=`${i}_${r}`;if(s.has(o)){const n=e+t,r=s.get(o);f[n]=r,f[r]=n,s.delete(o),p+=2,m.delete(r)}else{const n=`${r}_${i}`,o=e+t;s.set(n,o),m.add(o)}}}if(r){const{fragmentMap:e,disjointConnectivityMap:n}=O(t,m,i);m.clear(),e.forEach((({forward:t,reverse:e})=>{t.forEach((({index:t})=>m.add(t))),e.forEach((({index:t})=>m.add(t)))})),this.unmatchedDisjointEdges=e,this.disjointConnections=n,p=3*d-m.size}this.matchedEdges=p,this.unmatchedEdges=m.size,this.data=f}}class K extends o{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new s,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,r=e.elements;for(let t=0;t<16;t++)if(n[t]!==r[t])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=_();if(n)for(const t in e){const n=e[t];if(n.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");n.array=G(n.array)}if(t.boundsTree||(V(t,{useSharedArrayBuffer:n}),t.boundsTree=new v(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new Z(t)),!t.groupIndices){const e=P(t),n=new Uint16Array(e),r=t.groups;for(let t=0,e=r.length;t<e;t++){const{start:e,count:i}=r[t];for(let r=e/3,o=(e+i)/3;r<o;r++)n[r]=t}t.groupIndices=n}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const J=new e,Q=new e,tt=new e;function et(t,e=1e-14){J.subVectors(t.b,t.a),Q.subVectors(t.c,t.a),tt.subVectors(t.b,t.c);const n=J.angleTo(Q),r=J.angleTo(tt),i=Math.PI-n-r;return Math.abs(n)<e||Math.abs(r)<e||Math.abs(i)<e||t.a.distanceToSquared(t.b)<e||t.a.distanceToSquared(t.c)<e||t.b.distanceToSquared(t.c)<e}const nt=1e-10,rt=1e-10,it=new a,ot=new a,st=new e,at=new e,ct=new e,lt=new c,ut=new S;class dt{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new l),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class ht{constructor(){this.trianglePool=new dt,this.triangles=[],this.normal=new e,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:r}=this;if(Array.isArray(t))for(let i=0,o=t.length;i<o;i++){const o=t[i];if(0===i)o.getNormal(r);else if(Math.abs(1-o.getNormal(st).dot(r))>nt)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const s=n.getTriangle();s.copy(o),e.push(s)}else{t.getNormal(r);const i=n.getTriangle();i.copy(t),e.push(i)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(at).normalize(),Math.abs(1-Math.abs(at.dot(e)))<1e-10){this.coplanarTriangleUsed=!0;for(let t=0,e=n.length;t<e;t++){n[t].coplanarCount=0}const e=[t.a,t.b,t.c];for(let n=0;n<3;n++){const r=(n+1)%3,i=e[n],o=e[r];st.subVectors(o,i).normalize(),ct.crossVectors(at,st),lt.setFromNormalAndCoplanarPoint(ct,i),this.splitByPlane(lt,t)}}else t.getPlane(lt),this.splitByPlane(lt,t)}splitByPlane(t,e){const{triangles:n,trianglePool:r}=this;ut.copy(e),ut.needsUpdate=!0;for(let e=0,i=n.length;e<i;e++){const o=n[e];if(!ut.intersectsTriangle(o,it,!0))continue;const{a:s,b:a,c:c}=o;let l=0,u=-1,d=!1,h=[],g=[];const f=[s,a,c];for(let e=0;e<3;e++){const n=(e+1)%3;it.start.copy(f[e]),it.end.copy(f[n]);const r=t.distanceToPoint(it.start),i=t.distanceToPoint(it.end);if(Math.abs(r)<rt&&Math.abs(i)<rt){d=!0;break}if(r>0?h.push(e):g.push(e),Math.abs(r)<rt)continue;let o=!!t.intersectLine(it,st);!o&&Math.abs(i)<rt&&(st.copy(it.end),o=!0),!o||st.distanceTo(it.start)<nt||(st.distanceTo(it.end)<nt&&(u=e),0===l?ot.start.copy(st):ot.end.copy(st),l++)}if(!d&&2===l&&ot.distance()>rt)if(-1!==u){u=(u+1)%3;let t=0;t===u&&(t=(t+1)%3);let s=t+1;s===u&&(s=(s+1)%3);const a=r.getTriangle();a.a.copy(f[s]),a.b.copy(ot.end),a.c.copy(ot.start),et(a)||n.push(a),o.a.copy(f[t]),o.b.copy(ot.start),o.c.copy(ot.end),et(o)&&(n.splice(e,1),e--,i--)}else{const t=h.length>=2?g[0]:h[0];if(0===t){let t=ot.start;ot.start=ot.end,ot.end=t}const s=(t+1)%3,a=(t+2)%3,c=r.getTriangle(),l=r.getTriangle();f[s].distanceToSquared(ot.start)<f[a].distanceToSquared(ot.end)?(c.a.copy(f[s]),c.b.copy(ot.start),c.c.copy(ot.end),l.a.copy(f[s]),l.b.copy(f[a]),l.c.copy(ot.start)):(c.a.copy(f[a]),c.b.copy(ot.start),c.c.copy(ot.end),l.a.copy(f[s]),l.b.copy(f[a]),l.c.copy(ot.end)),o.a.copy(f[t]),o.b.copy(ot.end),o.c.copy(ot.start),et(c)||n.push(c),et(l)||n.push(l),et(o)&&(n.splice(e,1),e--,i--)}else 3===l&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}class gt{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(0!==this.length)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=new e(new(_()?SharedArrayBuffer:ArrayBuffer)(4+(r=~~(r=t*e.BYTES_PER_ELEMENT))-r%4));var r;this.array&&n.set(this.array,0),this.array=n}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:n}=this;n+t.length>e.length&&(this.expand(),e=this.array);for(let r=0,i=t.length;r<i;r++)e[n+r]=t[r];this.length+=t.length}clear(){this.length=0}}class ft{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let r=0;for(let i=0;i<e;i++){r+=n[i][t].length}return r}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const t={};e.push(t);for(const e in n){const r=n[e],i=new gt(r.type);i.itemSize=r.itemSize,i.normalized=r.normalized,t[e]=i}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:n}=this;if(!n[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,r){const{groupAttributes:i}=this,o=i[0][t];if(o){if(o.type!==e)for(let o=0,s=i.length;o<s;o++){const s=i[o][t];s.setType(e),s.itemSize=n,s.normalized=r}}else for(let o=0,s=i.length;o<s;o++){const s=new gt(e);s.itemSize=n,s.normalized=r,i[o][t]=s}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach((t=>{for(const e in t)t[e].clear()}))}delete(t){this.groupAttributes.forEach((e=>{delete e[t]}))}reset(){this.groupAttributes=[],this.groupCount=0}}class pt{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:r}=this;n[t]||(n[t]=[],r.push(t)),n[t].push(e)}}const mt=0,yt=1,bt=2,wt=3,xt=4,At=5,vt=6,St=new n,Tt=new s,Mt=new l,Bt=new e,zt=new i,Et=new i,It=new i,Ct=new i,_t=new i,Gt=new i,Vt=new a,Pt=new e,jt=1e-8,kt=-1;let Xt=null;function Dt(t){Xt=t}function $t(t,e){t.getMidpoint(St.origin),t.getNormal(St.direction);const n=e.raycastFirst(St,u);return Boolean(n&&St.direction.dot(n.face.normal)>0)?kt:1}function Wt(t,e){function n(){return Math.random()-.5}t.getNormal(Pt),St.direction.copy(Pt),t.getMidpoint(St.origin);let r=0,i=1/0;for(let t=0;t<3;t++){St.direction.x+=n()*jt,St.direction.y+=n()*jt,St.direction.z+=n()*jt,St.direction.multiplyScalar(-1);const o=e.raycastFirst(St,u);if(Boolean(o&&St.direction.dot(o.face.normal)>0)&&r++,null!==o&&(i=Math.min(i,o.distance)),i<=1e-15)return o.face.normal.dot(Pt)>0?2:-2;if(r/3>.5||(t-r+1)/3>.5)break}return r/3>.5?kt:1}function Nt(t,e,n,r,i,o,s=!1){const a=n.attributes,c=n.index,l=3*t,u=c.getX(l+0),d=c.getX(l+1),h=c.getX(l+2);for(const t in o){const n=a[t],c=o[t];if(!(t in a))throw new Error(`CSG Operations: Attribute ${t} not available on geometry.`);const l=n.itemSize;"position"===t?(Mt.a.fromBufferAttribute(n,u).applyMatrix4(r),Mt.b.fromBufferAttribute(n,d).applyMatrix4(r),Mt.c.fromBufferAttribute(n,h).applyMatrix4(r),Ut(Mt.a,Mt.b,Mt.c,e,3,c,s)):"normal"===t?(Mt.a.fromBufferAttribute(n,u).applyNormalMatrix(i),Mt.b.fromBufferAttribute(n,d).applyNormalMatrix(i),Mt.c.fromBufferAttribute(n,h).applyNormalMatrix(i),s&&(Mt.a.multiplyScalar(-1),Mt.b.multiplyScalar(-1),Mt.c.multiplyScalar(-1)),Ut(Mt.a,Mt.b,Mt.c,e,3,c,s,!0)):(zt.fromBufferAttribute(n,u),Et.fromBufferAttribute(n,d),It.fromBufferAttribute(n,h),Ut(zt,Et,It,e,l,c,s))}}function Rt(t,e,n,r,i,o,s,a=!1){Ot(t,r,i,o,s,a),Ot(a?n:e,r,i,o,s,a),Ot(a?e:n,r,i,o,s,a)}function Ft(t,e,n=!1){switch(t){case 0:if(1===e||2===e&&!n)return 1;break;case 1:if(n){if(e===kt)return 0}else if(1===e||-2===e)return 1;break;case 2:if(n){if(1===e||-2===e)return 1}else if(e===kt)return 0;break;case 4:if(e===kt)return 0;if(1===e)return 1;break;case 3:if(e===kt||2===e&&!n)return 1;break;case 5:if(!n&&(1===e||-2===e))return 1;break;case 6:if(!n&&(e===kt||2===e))return 1;break;default:throw new Error(`Unrecognized CSG operation enum "${t}".`)}return 2}function Ut(t,e,n,r,i,o,s=!1,a=!1){const c=t=>{o.push(t.x),i>1&&o.push(t.y),i>2&&o.push(t.z),i>3&&o.push(t.w)};Ct.set(0,0,0,0).addScaledVector(t,r.a.x).addScaledVector(e,r.a.y).addScaledVector(n,r.a.z),_t.set(0,0,0,0).addScaledVector(t,r.b.x).addScaledVector(e,r.b.y).addScaledVector(n,r.b.z),Gt.set(0,0,0,0).addScaledVector(t,r.c.x).addScaledVector(e,r.c.y).addScaledVector(n,r.c.z),a&&(Ct.normalize(),_t.normalize(),Gt.normalize()),c(Ct),s?(c(Gt),c(_t)):(c(_t),c(Gt))}function Ot(t,e,n,r,i,o=!1){for(const s in i){const a=e[s],c=i[s];if(!(s in e))throw new Error(`CSG Operations: Attribute ${s} no available on geometry.`);const l=a.itemSize;"position"===s?(Bt.fromBufferAttribute(a,t).applyMatrix4(n),c.push(Bt.x,Bt.y,Bt.z)):"normal"===s?(Bt.fromBufferAttribute(a,t).applyNormalMatrix(r),o&&Bt.multiplyScalar(-1),c.push(Bt.x,Bt.y,Bt.z)):(c.push(a.getX(t)),l>1&&c.push(a.getY(t)),l>2&&c.push(a.getZ(t)),l>3&&c.push(a.getW(t)))}}class Lt{constructor(t){this.triangle=(new l).copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=(new l).copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class Ht{constructor(){this.data={}}addTriangleIntersection(t,e,n,r){const{data:i}=this;i[t]||(i[t]=new Lt(e)),i[t].addTriangle(n,r)}getTrianglesAsArray(t=null){const{data:e}=this,n=[];if(null!==t)t in e&&n.push(e[t].triangle);else for(const t in e)n.push(e[t].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map((t=>parseInt(t)))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map((t=>parseInt(t))):[]}getIntersectionsAsArray(t=null,e=null){const{data:n}=this,r=new Set,i=[],o=t=>{if(n[t])if(null!==e)n[t].intersects[e]&&i.push(n[t].intersects[e]);else{const e=n[t].intersects;for(const t in e)r.has(t)||(r.add(t),i.push(e[t]))}};if(null!==t)o(t);else for(const t in n)o(t);return i}reset(){this.data={}}}class qt{constructor(){this.enabled=!1,this.triangleIntersectsA=new Ht,this.triangleIntersectsB=new Ht,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,r){const{triangleIntersectsA:i,triangleIntersectsB:o}=this;i.addTriangleIntersection(t,e,n,r),o.addTriangleIntersection(n,r,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),Dt(this))}complete(){this.enabled&&Dt(null)}}const Yt=new s,Zt=new d,Kt=new l,Jt=new l,Qt=new l,te=new l,ee=[],ne=[];function re(t){for(const e of t)return e}function ie(t,e,n,r,i,o={}){const{useGroups:s=!0}=o,{aIntersections:a,bIntersections:c}=function(t,e){const n=new pt,r=new pt;return Tt.copy(t.matrixWorld).invert().multiply(e.matrixWorld),t.geometry.boundsTree.bvhcast(e.geometry.boundsTree,Tt,{intersectsTriangles(i,o,s,a){if(!et(i)&&!et(o)){let c=i.intersectsTriangle(o,Vt,!0);if(!c){const t=i.plane,e=o.plane,n=t.normal,r=e.normal;1===n.dot(r)&&Math.abs(t.constant-e.constant)<1e-14&&(c=!0)}if(c){let c=t.geometry.boundsTree.resolveTriangleIndex(s),l=e.geometry.boundsTree.resolveTriangleIndex(a);n.add(c,l),r.add(l,c),Xt&&(Xt.addEdge(Vt),Xt.addIntersectingTriangles(s,i,a,o))}}return!1}}),{aIntersections:n,bIntersections:r}}(t,e);let l;l=s?0:-1,oe(t,e,a,n,!1,r,i,l),se(t,e,a,n,!1,i,l);return-1!==n.findIndex((t=>6!==t&&5!==t))&&(l=s?t.geometry.groups.length||1:-1,oe(e,t,c,n,!0,r,i,l),se(e,t,c,n,!0,i,l)),ee.length=0,ne.length=0,{groups:[],materials:null}}function oe(t,e,n,r,i,o,s,a=0){const c=t.matrixWorld.determinant()<0;Yt.copy(e.matrixWorld).invert().multiply(t.matrixWorld),Zt.getNormalMatrix(t.matrixWorld).multiplyScalar(c?-1:1);const l=t.geometry.groupIndices,u=t.geometry.index,d=t.geometry.attributes.position,h=e.geometry.boundsTree,g=e.geometry.index,f=e.geometry.attributes.position,p=n.ids,m=n.intersectionSet;for(let e=0,n=p.length;e<n;e++){const n=p[e],y=-1===a?0:l[n]+a,b=3*n,w=u.getX(b+0),x=u.getX(b+1),A=u.getX(b+2);Kt.a.fromBufferAttribute(d,w).applyMatrix4(Yt),Kt.b.fromBufferAttribute(d,x).applyMatrix4(Yt),Kt.c.fromBufferAttribute(d,A).applyMatrix4(Yt),o.reset(),o.initialize(Kt);const v=m[n];for(let t=0,e=v.length;t<e;t++){const e=3*v[t],n=g.getX(e+0),r=g.getX(e+1),i=g.getX(e+2);Jt.a.fromBufferAttribute(f,n),Jt.b.fromBufferAttribute(f,r),Jt.c.fromBufferAttribute(f,i),o.splitByTriangle(Jt)}const S=o.triangles;for(let e=0,a=S.length;e<a;e++){const a=S[e],l=o.coplanarTriangleUsed?Wt(a,h):$t(a,h);ee.length=0,ne.length=0;for(let t=0,e=r.length;t<e;t++){const e=Ft(r[t],l,i);2!==e&&(ne.push(e),ee.push(s[t].getGroupAttrSet(y)))}if(0!==ee.length){Kt.getBarycoord(a.a,te.a),Kt.getBarycoord(a.b,te.b),Kt.getBarycoord(a.c,te.c);for(let e=0,r=ee.length;e<r;e++){const r=ee[e],i=0===ne[e];Nt(n,te,t.geometry,t.matrixWorld,Zt,r,c!==i)}}}}return p.length}function se(t,e,n,r,i,o,s=0){const a=t.matrixWorld.determinant()<0;Yt.copy(e.matrixWorld).invert().multiply(t.matrixWorld),Zt.getNormalMatrix(t.matrixWorld).multiplyScalar(a?-1:1);const c=e.geometry.boundsTree,l=t.geometry.groupIndices,u=t.geometry.index,d=t.geometry.attributes,h=d.position,g=[],f=t.geometry.halfEdges,p=new Set;for(let e=0,r=P(t.geometry);e<r;e++)e in n.intersectionSet||p.add(e);for(;p.size>0;){const e=re(p);p.delete(e),g.push(e);const n=3*e,m=u.getX(n+0),y=u.getX(n+1),b=u.getX(n+2);Qt.a.fromBufferAttribute(h,m).applyMatrix4(Yt),Qt.b.fromBufferAttribute(h,y).applyMatrix4(Yt),Qt.c.fromBufferAttribute(h,b).applyMatrix4(Yt);const w=$t(Qt,c);ne.length=0,ee.length=0;for(let t=0,e=r.length;t<e;t++){const e=Ft(r[t],w,i);2!==e&&(ne.push(e),ee.push(o[t]))}for(;g.length>0;){const e=g.pop();for(let t=0;t<3;t++){const n=f.getSiblingTriangleIndex(e,t);-1!==n&&p.has(n)&&(g.push(n),p.delete(n))}if(0!==ee.length){const n=3*e,r=u.getX(n+0),i=u.getX(n+1),o=u.getX(n+2),c=-1===s?0:l[e]+s;if(Qt.a.fromBufferAttribute(h,r),Qt.b.fromBufferAttribute(h,i),Qt.c.fromBufferAttribute(h,o),!et(Qt))for(let e=0,n=ee.length;e<n;e++){const n=ne[e],s=ee[e].getGroupAttrSet(c),l=0===n;Rt(r,i,o,d,t.matrixWorld,Zt,s,l!==a)}}}}}function ae(t,e){let n=e;return Array.isArray(e)||(n=[],t.forEach((t=>{n[t.materialIndex]=e}))),n}class ce{constructor(){this.triangleSplitter=new ht,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new qt}getGroupRanges(t){return this.useGroups&&0!==t.groups.length?t.groups.map((t=>({...t}))):[{start:0,count:1/0,materialIndex:0}]}evaluate(e,n,r,i=new K){let o=!0;if(Array.isArray(r)||(r=[r]),Array.isArray(i)||(i=[i],o=!1),i.length!==r.length)throw new Error("Evaluator: operations and target array passed as different sizes.");e.prepareGeometry(),n.prepareGeometry();const{triangleSplitter:s,attributeData:a,attributes:c,useGroups:l,consolidateGroups:u,debug:d}=this;for(;a.length<i.length;)a.push(new ft);i.forEach(((t,n)=>{!function(t,e,n,r){n.clear();const i=t.attributes;for(let t=0,e=r.length;t<e;t++){const e=r[t],o=i[e];n.initializeArray(e,o.array.constructor,o.itemSize,o.normalized)}for(const t in n.attributes)r.includes(t)||n.delete(t);for(const t in e.attributes)r.includes(t)||(e.deleteAttribute(t),e.dispose())}(e.geometry,t.geometry,a[n],c)})),d.init(),ie(e,n,r,s,a,{useGroups:l}),d.complete();const h=this.getGroupRanges(e.geometry),g=ae(h,e.material),f=this.getGroupRanges(n.geometry),p=ae(f,n.material);f.forEach((t=>t.materialIndex+=g.length));let m=[...h,...f].map(((t,e)=>({...t,index:e})));if(l){const t=[...g,...p];u&&(m=m.map((e=>{const n=t[e.materialIndex];return e.materialIndex=t.indexOf(n),e})).sort(((t,e)=>t.materialIndex-e.materialIndex)));const e=[];for(let n=0,r=t.length;n<r;n++){let r=!1;for(let t=0,i=m.length;t<i;t++){const i=m[t];i.materialIndex===n&&(r=!0,i.materialIndex=e.length)}r&&e.push(t[n])}i.forEach((t=>{t.material=e}))}else m=[{start:0,count:1/0,index:0,materialIndex:0}],i.forEach((t=>{t.material=g[0]}));return i.forEach(((e,n)=>{const r=e.geometry;!function(e,n,r){let i=!1,o=-1;const s=e.attributes,a=n.groupAttributes[0];for(const c in a){const a=n.getTotalLength(c),l=n.getType(c),u=n.getItemSize(c),d=n.getNormalized(c);let h=s[c];(!h||h.array.length<a)&&(h=new t(new l(a),u,d),e.setAttribute(c,h),i=!0);let g=0;for(let t=0,e=Math.min(r.length,n.groupCount);t<e;t++){const e=r[t].index,{array:i,type:o,length:s}=n.groupAttributes[e][c],a=new o(i.buffer,0,s);h.array.set(a,g),g+=a.length}h.needsUpdate=!0,o=a/h.itemSize}if(e.index){const t=e.index.array;if(t.length<o)e.index=null,i=!0;else for(let e=0,n=t.length;e<n;e++)t[e]=e}let c=0;e.clearGroups();for(let t=0,i=Math.min(r.length,n.groupCount);t<i;t++){const{index:i,materialIndex:o}=r[t],s=n.getCount(i);0!==s&&(e.addGroup(c,s,o),c+=s)}e.setDrawRange(0,o),e.boundsTree=null,i&&e.dispose()}(r,a[n],m),u&&function(t){for(let e=0;e<t.length-1;e++){const n=t[e],r=t[e+1];if(n.materialIndex===r.materialIndex){const i=n.start,o=r.start+r.count;r.start=i,r.count=o-i,t.splice(e,1),e--}}}(r.groups)})),o?i:i[0]}evaluateHierarchy(t,e=new K){t.updateMatrixWorld(!0);const n=(t,e)=>{const r=t.children;for(let t=0,i=r.length;t<i;t++){const i=r[t];i.isOperationGroup?n(i,e):e(i)}},r=t=>{const e=t.children;let i=!1;for(let t=0,n=e.length;t<n;t++){const n=e[t];i=r(n)||i}const o=t.isDirty();if(o&&t.markUpdated(),i&&!t.isOperationGroup){let e;return n(t,(n=>{e=e?this.evaluate(e,n,n.operation):this.evaluate(t,n,n.operation)})),t._cachedGeometry=e.geometry,t._cachedMaterials=e.material,!0}return i||o};return r(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}class le extends K{constructor(...t){super(...t),this.isOperation=!0,this.operation=0,this._cachedGeometry=new h,this._cachedMaterials=null,this._previousOperation=null}markUpdated(){super.markUpdated(),this._previousOperation=this.operation}isDirty(){return this.operation!==this._previousOperation||super.isDirty()}insertBefore(t){const e=this.parent,n=e.children.indexOf(this);e.children.splice(n,0,t)}insertAfter(t){const e=this.parent,n=e.children.indexOf(this);e.children.splice(n+1,0,t)}}class ue extends g{constructor(){super(),this.isOperationGroup=!0,this._previousMatrix=new s}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,r=e.elements;for(let t=0;t<16;t++)if(n[t]!==r[t])return!0;return!1}}class de extends p{get enableGrid(){return Boolean(this._enableGrid)}set enableGrid(t){this._enableGrid!==t&&(this._enableGrid=t,this.needsUpdate=!0)}constructor(...t){super(...t),this.enableGrid=!0}onBeforeCompile(t){!function(t){t.uniforms={...t.uniforms,checkerboardColor:{value:new f(1118481)}},function(t){/varying\s+vec3\s+wPosition/.test(t.vertexShader)||(t.vertexShader=`\n\t\t\tvarying vec3 wPosition;\n\t\t\t${t.vertexShader}\n\t\t`.replace(/#include <displacementmap_vertex>/,(t=>`${t}\n\t\t\t\twPosition = (modelMatrix * vec4( transformed, 1.0 )).xyz;\n\t\t\t\t`)),t.fragmentShader=`\n\t\tvarying vec3 wPosition;\n\t\t${t.fragmentShader}\n\t\t`)}(t),t.defines={CSG_GRID:1},t.fragmentShader=t.fragmentShader.replace(/#include <common>/,(t=>`\n\t\t\t${t}\n\n\t\t\tuniform vec3 checkerboardColor;\n\t\t\tfloat getCheckerboard( vec2 p, float scale ) {\n\n\t\t\t\tp /= scale;\n\t\t\t\tp += vec2( 0.5 );\n\n\t\t\t\tvec2 line = mod( p, 2.0 ) - vec2( 1.0 );\n\t\t\t\tline = abs( line );\n\n\t\t\t\tvec2 pWidth = fwidth( line );\n\t\t\t\tvec2 value = smoothstep( 0.5 - pWidth / 2.0, 0.5 + pWidth / 2.0, line );\n\t\t\t\tfloat result = value.x * value.y + ( 1.0 - value.x ) * ( 1.0 - value.y );\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\tfloat getGrid( vec2 p, float scale, float thickness ) {\n\n\t\t\t\tp /= 0.5 * scale;\n\n\t\t\t\tvec2 stride = mod( p, 2.0 ) - vec2( 1.0 );\n\t\t\t\tstride = abs( stride );\n\n\t\t\t\tvec2 pWidth = fwidth( p );\n\t\t\t\tvec2 line = smoothstep( 1.0 - pWidth / 2.0, 1.0 + pWidth / 2.0, stride + thickness * pWidth );\n\n\t\t\t\treturn max( line.x, line.y );\n\n\t\t\t}\n\n\t\t\tvec3 getFaceColor( vec2 p, vec3 color ) {\n\n\t\t\t\tfloat checkLarge = getCheckerboard( p, 1.0 );\n\t\t\t\tfloat checkSmall = abs( getCheckerboard( p, 0.1 ) );\n\t\t\t\tfloat lines = getGrid( p, 10.0, 1.0 );\n\n\t\t\t\tvec3 checkColor = mix(\n\t\t\t\t\tvec3( 0.7 ) * color,\n\t\t\t\t\tvec3( 1.0 ) * color,\n\t\t\t\t\tcheckSmall * 0.4 + checkLarge * 0.6\n\t\t\t\t);\n\n\t\t\t\tvec3 gridColor = vec3( 1.0 );\n\n\t\t\t\treturn mix( checkColor, gridColor, lines );\n\n\t\t\t}\n\n\t\t\tfloat angleBetween( vec3 a, vec3 b ) {\n\n\t\t\t\treturn acos( abs( dot( a, b ) ) );\n\n\t\t\t}\n\n\t\t\tvec3 planeProject( vec3 norm, vec3 other ) {\n\n\t\t\t\tfloat d = dot( norm, other );\n\t\t\t\treturn normalize( other - norm * d );\n\n\t\t\t}\n\n\t\t\tvec3 getBlendFactors( vec3 norm ) {\n\n\t\t\t\tvec3 xVec = vec3( 1.0, 0.0, 0.0 );\n\t\t\t\tvec3 yVec = vec3( 0.0, 1.0, 0.0 );\n\t\t\t\tvec3 zVec = vec3( 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 projX = planeProject( xVec, norm );\n\t\t\t\tvec3 projY = planeProject( yVec, norm );\n\t\t\t\tvec3 projZ = planeProject( zVec, norm );\n\n\t\t\t\tfloat xAngle = max(\n\t\t\t\t\tangleBetween( xVec, projY ),\n\t\t\t\t\tangleBetween( xVec, projZ )\n\t\t\t\t);\n\n\t\t\t\tfloat yAngle = max(\n\t\t\t\t\tangleBetween( yVec, projX ),\n\t\t\t\t\tangleBetween( yVec, projZ )\n\t\t\t\t);\n\n\t\t\t\tfloat zAngle = max(\n\t\t\t\t\tangleBetween( zVec, projX ),\n\t\t\t\t\tangleBetween( zVec, projY )\n\t\t\t\t);\n\n\t\t\t\treturn vec3( xAngle, yAngle, zAngle ) / ( 0.5 * PI );\n\n\t\t\t}\n\t\t`)).replace(/#include <normal_fragment_maps>/,(t=>`${t}\n\t\t\t\t#if CSG_GRID\n\t\t\t\t{\n\n\t\t\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t\t\t\tfloat yCont = abs( dot( vec3( 0.0, 1.0, 0.0 ), worldNormal ) );\n\t\t\t\t\tfloat zCont = abs( dot( vec3( 0.0, 0.0, 1.0 ), worldNormal ) );\n\t\t\t\t\tfloat xCont = abs( dot( vec3( 1.0, 0.0, 0.0 ), worldNormal ) );\n\n\t\t\t\t\tvec3 factors = getBlendFactors( worldNormal );\n\t\t\t\t\tfactors = smoothstep( vec3( 0.475 ), vec3( 0.525 ), vec3( 1.0 ) - factors );\n\n\t\t\t\t\tfloat weight = factors.x + factors.y + factors.z;\n\t\t\t\t\tfactors /= weight;\n\n\t\t\t\t\tvec3 color =\n\t\t\t\t\t\tgetFaceColor( wPosition.yz, diffuseColor.rgb ) * factors.x +\n\t\t\t\t\t\tgetFaceColor( wPosition.xz, diffuseColor.rgb ) * factors.y +\n\t\t\t\t\t\tgetFaceColor( wPosition.xy, diffuseColor.rgb ) * factors.z;\n\n\t\t\t\t\tdiffuseColor.rgb = color;\n\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t`))}(t),t.defines.CSG_GRID=Number(this.enableGrid)}customProgramCacheKey(){return this.enableGrid.toString()}}function he(...t){function e(t){return`new THREE.Vector3( ${t.x}, ${t.y}, ${t.z} )`}return t.map((t=>`\nnew THREE.Triangle(\n\t${e(t.a)},\n\t${e(t.b)},\n\t${e(t.c)},\n)\n\t\t`.trim()))}function ge(...t){console.log(he(...t).join(",\n"))}function fe(e){const n=e.attributes.position,r=new Float32Array(3*n.count),i=new f;for(let t=0,e=r.length;t<e;t+=9)i.setHSL(Math.random(),m.lerp(.5,1,Math.random()),m.lerp(.5,.75,Math.random())),r[t+0]=i.r,r[t+1]=i.g,r[t+2]=i.b,r[t+3]=i.r,r[t+4]=i.g,r[t+5]=i.b,r[t+6]=i.r,r[t+7]=i.g,r[t+8]=i.b;e.setAttribute("color",new t(r,3))}class pe extends g{get color(){return this._mesh.material.color}get side(){return this._mesh.material.side}set side(t){this._mesh.material.side=t}constructor(t=[]){super();const e=new h,n=new h;this._mesh=new o(e,new p({flatShading:!0,transparent:!0,opacity:.25,depthWrite:!1})),this._lines=new y(n,new b),this._mesh.material.color=this._lines.material.color,this._lines.frustumCulled=!1,this._mesh.frustumCulled=!1,this.add(this._lines,this._mesh),this.setTriangles(t)}setTriangles(e){const n=new Float32Array(9*e.length),r=new Float32Array(18*e.length);for(let t=0,i=e.length;t<i;t++){const i=9*t,o=18*t,s=e[t];s.a.toArray(n,i+0),s.b.toArray(n,i+3),s.c.toArray(n,i+6),s.a.toArray(r,o+0),s.b.toArray(r,o+3),s.b.toArray(r,o+6),s.c.toArray(r,o+9),s.c.toArray(r,o+12),s.a.toArray(r,o+15)}this._mesh.geometry.dispose(),this._mesh.geometry.setAttribute("position",new t(n,3)),this._lines.geometry.dispose(),this._lines.geometry.setAttribute("position",new t(r,3))}}class me extends y{get color(){return this.material.color}constructor(t=[]){super(),this.frustumCulled=!1,this.setEdges(t)}setEdges(t){const{geometry:e}=this,n=t.flatMap((t=>[t.start,t.end]));e.dispose(),e.setFromPoints(n)}}const ye=new s;class be extends w{get color(){return this.material.color}constructor(t=1e3,e=[]){super(new x(.025),new A,t),this.frustumCulled=!1,this.setPoints(e)}setPoints(t){for(let e=0,n=t.length;e<n;e++){const n=t[e];ye.makeTranslation(n.x,n.y,n.z),this.setMatrixAt(e,ye)}this.count=t.length}}const we=["a","b","c"],xe=new l,Ae=new l,ve=new e,Se=new e,Te=new e,Me=new e,Be=new e,ze=new e,Ee=new e,Ie=new e,Ce=new e,_e=new e,Ge=new e,Ve=new e,Pe=new c,je=new c,ke=new e,Xe=new n,De=new a;function $e(t,e,n){const r=3*e;let i=r+0,o=r+1,s=r+2;const a=t.index,c=t.attributes.position;return a&&(i=a.getX(i),o=a.getX(o),s=a.getX(s)),n.a.fromBufferAttribute(c,i),n.b.fromBufferAttribute(c,o),n.c.fromBufferAttribute(c,s),n}function We(t,e,n,r,i){const o=(e+1)%3,s=t[we[e]],a=t[we[o]],c=(r+1)%3,l=n[we[r]],u=n[we[c]];C(s,a,Xe);let d=Ce.subVectors(s,Xe.origin).dot(Xe.direction),h=Ce.subVectors(a,Xe.origin).dot(Xe.direction);d>h&&([d,h]=[h,d]);let g=Ce.subVectors(l,Xe.origin).dot(Xe.direction),f=Ce.subVectors(u,Xe.origin).dot(Xe.direction);g>f&&([g,f]=[f,g]);const p=Math.max(d,g),m=Math.min(h,f);Xe.at(p,i.start),Xe.at(m,i.end)}class Ne extends me{constructor(t=null,e=null){super(),this.straightEdges=!1,this.displayDisconnectedEdges=!1,t&&e&&this.setHalfEdges(t,e)}setHalfEdges(t,e){const{straightEdges:n,displayDisconnectedEdges:r}=this,i=[],o=t.drawRange.start;let s=P(t);if(t.drawRange.count!==1/0&&(s=~~(t.drawRange.count/3)),r)if(e.unmatchedDisjointEdges)e.unmatchedDisjointEdges.forEach((({forward:t,reverse:e,ray:n})=>{[...t,...e].forEach((({start:t,end:e})=>{const r=new a;n.at(t,r.start),n.at(e,r.end),i.push(r)}))}));else for(let n=o;n<s;n++){$e(t,n,xe);for(let t=0;t<3;t++){if(-1===e.getSiblingTriangleIndex(n,t)){const e=(t+1)%3,n=xe[we[t]],r=xe[we[e]],o=new a;o.start.copy(n),o.end.copy(r),i.push(o)}}}else for(let n=o;n<s;n++){$e(t,n,xe);for(let r=0;r<3;r++){const i=e.getSiblingTriangleIndex(n,r);if(-1===i)continue;$e(t,i,Ae);const o=(r+1)%3,s=xe[we[r]],a=xe[we[o]];ke.lerpVectors(s,a,.5),c(xe,Ae,ke)}if(e.disjointConnections)for(let r=0;r<3;r++){const i=e.getDisjointSiblingTriangleIndices(n,r),o=e.getDisjointSiblingEdgeIndices(n,r);for(let e=0;e<i.length;e++){const n=i[e],s=o[e];$e(t,n,Ae),We(xe,r,Ae,s,De),ke.lerpVectors(De.start,De.end,.5),c(xe,Ae,ke)}}}function c(t,e,r){t.getMidpoint(ve),e.getMidpoint(Se),t.getPlane(Pe),e.getPlane(je);const o=new a;o.start.copy(ve),n?(Pe.projectPoint(Se,Te),je.projectPoint(ve,Me),Be.subVectors(Te,ve),ze.subVectors(Me,Se),Ee.subVectors(r,ve),Ie.subVectors(r,Se),Be.dot(Ee)<0&&Be.multiplyScalar(-1),ze.dot(Ie)<0&&ze.multiplyScalar(-1),Ce.addVectors(ve,Be),_e.addVectors(Se,ze),t.closestPointToPoint(Ce,Ge),e.closestPointToPoint(_e,Ve),o.end.lerpVectors(Ge,Ve,.5)):o.end.copy(r),i.push(o)}super.setEdges(i)}}const Re=new l,Fe=new e,Ue=new e;function Oe(t){let e,n;t.isBufferGeometry?(e=t,n=null):(e=t.geometry,n=Math.abs(t.matrixWorld.determinant()-1)<1e-15?null:t.matrixWorld);const r=e.index,i=e.attributes.position,o=e.drawRange,s=Math.min(P(e),o.count/3);Re.setFromAttributeAndIndices(i,0,1,2),qe(Re,n),Re.getNormal(Fe),Re.getMidpoint(Ue).add(Fe);let a=0;const c=o.start/3;for(let t=c,e=c+s;t<e;t++){let e=3*t+0,o=3*t+1,s=3*t+2;r&&(e=r.getX(e),o=r.getX(o),s=r.getX(s)),Re.setFromAttributeAndIndices(i,e,o,s),qe(Re,n),He(Re,Ue),a+=Le(Re.a,Re.b,Re.c)}return Math.abs(a)}function Le(t,e,n){return 1/6*(-(n.x*e.y*t.z)+e.x*n.y*t.z+n.x*t.y*e.z-t.x*n.y*e.z-e.x*t.y*n.z+t.x*e.y*n.z)}function He(t,e){t.a.sub(e),t.b.sub(e),t.c.sub(e)}function qe(t,e=null){null!==e&&(t.a.applyMatrix4(e),t.b.applyMatrix4(e),t.c.applyMatrix4(e))}export{mt as ADDITION,K as Brush,xt as DIFFERENCE,me as EdgesHelper,ce as Evaluator,de as GridMaterial,vt as HOLLOW_INTERSECTION,At as HOLLOW_SUBTRACTION,Ne as HalfEdgeHelper,Z as HalfEdgeMap,wt as INTERSECTION,le as Operation,ue as OperationGroup,be as PointsHelper,bt as REVERSE_SUBTRACTION,yt as SUBTRACTION,pe as TriangleSetHelper,ht as TriangleSplitter,Oe as computeMeshVolume,fe as generateRandomTriangleColors,he as getTriangleDefinitions,ge as logTriangleDefinitions};export default null;
//# sourceMappingURL=/sm/72a1aa78338d200448de4c32130d908e243c70b73a5b8b732323a0959ee591ec.map