<!--
trails ... https://three-nebula.org/examples/point-zone
shiny ... https://threejs.org/examples/#webgl_materials_cubemap_dynamic
blurry ... https://github.com/Domenicobrz/Blurry [omfg]
most beautiful blobs ... https://blobmixer.14islands.com/

-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The Knowledge Cosmos</title>

    <link rel="stylesheet" type="text/css" href="/potree/potree.css">
    <link rel="stylesheet" type="text/css" href="/libs/jquery-ui/jquery-ui.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/openlayers3/ol.css">
    <link rel="stylesheet" type="text/css" href="/libs/spectrum/spectrum.css">
    <link rel="stylesheet" type="text/css" href="/libs/jstree/themes/mixed/style.css">"

    <style>
        @font-face {
            font-family: robo;
            src: url(/RobotoMono.ttf);
        }
        
        
        @font-face {
            font-family: cyber;
            src: url(/CyberGraphLight.ttf);
        }
        
        
    
        body {
            font-family: robo;/*, "Lato", Helvetica, Arial, Lucida, sans-serif;*/
        }
        body {
            font-family: robo;
            font-size: 10pt;
        }
        
        #legend {
            max-height: calc(100% - 100px);
            overflow-y: scroll;
        }
        
        #menu {
            position: absolute;
            top: 0;
            right: 0;
            color: white;
            z-index: 1;
            cursor: pointer;
            padding: 20px;
        }
        
        #menu .item {
            display: inline-block;
            margin-right: 3px;
            text-decoration: underline;
        }

        .swatch {
            width: 15px;
            height: 15px;
            display: inline-block;
            margin-right: 6px;
        }

        #game_info {
            color: black;
            background-color: rgba(255,255,255,1);
            font-size: 13pt;
            z-index: 2;
            position: absolute;
            padding: 10px 20px;
            margin: 10px;
            border: solid 20px rgb(50, 10, 43);
            bottom: 0; left: 0;
        }

        #legend .legend_item {
            cursor: pointer;display: block;
        }

        .label {
            display: inline-block;
        }

        #game_info a, #paper_info a {
            color: black;
            text-decoration: underline;
        }

        #prettier_game_info {
            color: white;
            font-size: 18px;
            text-transform: none;
            position: relative;
            z-index: 2;
            margin: auto;
            top: 30%;
            width: 100%;
            max-width: 800px;
            padding: 10px;
            text-align: center; /* uncertain */
        }

        #labels .floating_text {
            position: absolute;
        }
        #labels {
            z-index: 2;
            color: white;
            position: absolute;
            top: 0;
            left: 0;
        }

        #reporting {
            color: black;
            background-color: rgba(255,255,255,0.7);
            font-size: 15px;
            position: absolute;
            z-index: 2;
            margin: auto;
            bottom: 0;
            padding: 2px;
            text-align: center;
            width: 100%;
        }
        
        #paper_info {
            color: black;
            background-color: rgb(255, 255, 255);
            font-size: 13px;
            z-index: 2;
            position: relative;
            padding: 2px;
            width: 30%;
            text-align: center;
            margin: auto;
            border-radius: 15px;
            padding: 10px;
            position: absolute;
            top: 60px;
            left: 35%;
        }
        
        #constellation p {
            margin: 0 0 20px;
            font-size: 10pt;
        }
        .right_boy {
            position: relative;
            float: right;
            width: 300px;
            z-index: 2;
            background-color: white;
            padding: 15px;
            border-radius: 15px;
            margin-right: 22px;
            margin-top: 5px;
        }
        
        .linky {
            display: inline-block;
            margin-right: 3px;
            text-decoration: underline;
            cursor: pointer;
            position: absolute;
            bottom: 22px;
            z-index: 2;
            color: white;
            padding: 15px;
        }
        
        #tips_link {
            left: 22px;
        }
        
        #comment_link {
            left: 80px;
        }
        
        
        #tips {
            color: black;
            background-color: rgba(255,255,255,1);
            font-size: 10pt;
            position: absolute;
            z-index: 2;
            bottom: 22px;
            left: 22px;
            padding: 15px;
            text-align: center;
            width: 400px;
            display: none;
            border-radius: 15px;
        }
        
        .lab {
            vertical-align: top;
            display: inline-block;
            line-height: 25px;
            font-size: 10pt;
        }
        
        #const_legend .legend_item {
            padding: 5px;
        }
            
        #const_legend {
            background-color: black;
            border-radius: 15px;
            margin-top: 10px;
            color: white;
        }
        
        #const_legend .link {
            text-decoration: underline;
            cursor: pointer;
            vertical-align: top;
            display: inline-block;
            line-height: 25px;
            margin-left: 5px;
        }
    </style>

    <style>
    .loading-placeholder {
        background: #e0e0e0;
        border-radius: 4px;
        animation: pulse 1.5s infinite;
        margin: 5px 0;
    }

    .loading-placeholder.title {
        height: 24px;
        width: 80%;
    }

    .loading-placeholder.meta {
        height: 16px;
        width: 60%;
    }

    .loading-placeholder.tags {
        height: 20px;
        width: 40%;
    }

    .loading-placeholder.content {
        height: 100px;
        width: 100%;
    }

    @keyframes pulse {
        0% {
            opacity: 0.6;
        }
        50% {
            opacity: 0.3;
        }
        100% {
            opacity: 0.6;
        }
    }
    </style>

    <style>
    .toggle-switch {
        width: 40px;
        height: 20px;
        background-color: #333;
        border-radius: 10px;
        position: relative;
        cursor: pointer;
        transition: background-color 0.3s;
    }

    .toggle-switch::before {
        content: '';
        position: absolute;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background-color: white;
        top: 2px;
        left: 2px;
        transition: transform 0.3s;
    }

    .toggle-switch.active {
        background-color: #4CAF50;
    }

    .toggle-switch.active::before {
        transform: translateX(20px);
    }

    .toolbar-item {
        position: relative;
    }

    .toolbar-item:hover .toggle-switch {
        background-color: #444;
    }

    .toolbar-item:hover .toggle-switch.active {
        background-color: #45a049;
    }
    </style>
</head>

<body>
    <script src="/libs/jquery/jquery-3.1.1.min.js"></script>
    <script src="/libs/spectrum/spectrum.js"></script>
    <script src="/libs/jquery-ui/jquery-ui.min.js"></script>
    <script src="/libs/other/BinaryHeap.js"></script>
    <script src="/libs/tween/tween.min.js"></script>
    <script src="/libs/d3/d3.js"></script>
    <script src="/libs/proj4/proj4.js"></script>
    <script src="/libs/openlayers3/ol.js"></script>
    <script src="/libs/i18next/i18next.js"></script>
    <script src="/libs/jstree/jstree.js"></script>
    <script src="/potree/potree.js"></script>
    <script src="https://fariskassim.com/stage/rebel9/teaf/blob/v4/js/perlin.js"></script>
    <script src="/libs/plasio/js/laslaz.js"></script>
    <script src="/libs/noise.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/sidebar.css">
    <link rel="stylesheet" type="text/css" href="/toolbar.css">
    <!--<script src="https://unpkg.com/d3-octree"></script>-->
    
    <!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
    <!-- INCLUDE SETTINGS HERE -->
    
    <div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">
        <div id="potree_render_area" style="background-color: black;"></div>
        <div id="potree_sidebar_container"> </div>
        <input id="tiffTest" type="button" value="tiff test" />
    </div>

    
    
    <script type="module">

    import {STLLoader} from "/libs/three.js/loaders/STLLoader.js";
    import * as THREE from "/libs/three.js/build/three.module.js";
    //import { PointOctree } from "sparse-octree";

    //import { DragControls } from '../libs/three.js/addons/controls/DragControls.js';

    /*
    const createMoveAnimation = ({ mesh, startPosition, endPosition }) => {
        mesh.cmixer = new THREE.AnimationMixer(mesh);
        let track = new THREE.VectorKeyframeTrack(
            '.position',
            [0, 1],
            [
            startPosition.x,
            startPosition.y,
            startPosition.z,
            endPosition.x,
            endPosition.y,
            endPosition.z,
            ]
        );
        const animationClip = new THREE.AnimationClip(null, 10, [track]);
        const animationAction = mesh.cmixer.clipAction(animationClip);

        animationAction.setLoop(THREE.LoopOnce);
        animationAction.play();

        mesh.cclock = new THREE.Clock();
        //this.animationsObjects.push(mesh);
    };
    */

    //const BASE = '/q';
    const BASE = 'http://127.0.0.1:1235';

    // used this for the book, which was a nicer aesthetic, sorta..
    // I can fine-tune the blob (or randomize it!)
    const sphereMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff, wireframe:true} );
    /*const sphereMaterial = new THREE.MeshLambertMaterial( {
        color: 0x049ef4,
        //emissive: 0x8e8e8e,
        shininess: 40
    } );*/

    
        window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"), {
            useDefaultRenderLoop: false,
            logarithmicDepthBuffer: true // don't think this does anything. I found it in a blog, that putting this into WebGLRenderer constructor reduces flickering from z-fighting
        });
        
        viewer.setEDLEnabled(false);
        viewer.setFOV(60);
        //viewer.setPointBudget(2_000_000);
        //viewer.setPointBudget(500_000);
        viewer.setPointBudget(750_000);
        viewer.setMinNodeSize(0);

        // fly around
        viewer.setControls(viewer.fpControls);
        viewer.fpControls.lockElevation = false;
        viewer.fpControls.rotationSpeed=50

        // Add control and camera mode functionality
        document.addEventListener('DOMContentLoaded', function() {
            const flightControl = document.getElementById('flight-control');
            const orbitControl = document.getElementById('orbit-control');
            const cameraPerspective = document.getElementById('camera-perspective');
            const cameraOrthographic = document.getElementById('camera-orthographic');
            
            // Set initial camera mode
            viewer.setCameraMode(Potree.CameraMode.PERSPECTIVE);
            
            // Control switching
            flightControl.addEventListener('click', function() {
                viewer.setControls(viewer.fpControls);
                viewer.fpControls.lockElevation = false;
                viewer.fpControls.rotationSpeed = 50;
                flightControl.classList.add('selected');
                orbitControl.classList.remove('selected');
            });
            
            orbitControl.addEventListener('click', function() {
                viewer.setControls(viewer.orbitControls);
                orbitControl.classList.add('selected');
                flightControl.classList.remove('selected');
            });
            
            // Camera mode switching
            cameraPerspective.addEventListener('click', function() {
                viewer.setCameraMode(Potree.CameraMode.PERSPECTIVE);
                cameraPerspective.classList.add('selected');
                cameraOrthographic.classList.remove('selected');
            });
            
            cameraOrthographic.addEventListener('click', function() {
                viewer.setCameraMode(Potree.CameraMode.ORTHOGRAPHIC);
                cameraOrthographic.classList.add('selected');
                cameraPerspective.classList.remove('selected');
            });
        });

        //viewer.loadSettingsFromURL();
        //viewer.setServer("http://localhost:1234");
        
        viewer.setDescription("");
        
        viewer.loadGUI().then(() => {
            viewer.setLanguage('en');
            $("#menu_appearance").next().show();
            // viewer.toggleSidebar();
        });
        
        /*
        let light = new THREE.SpotLight();
        light.distance = 15;
        light.angle = (60 / 180) * Math.PI;
        light.position.set(415.005, 354.499, 371.803);
        light.lookAt(new THREE.Vector3(1.219, -0.171, 2.776));
        viewer.scene.scene.add(light);
        */

        // the lights never followed, so I'll just use this ambient light
        // because I'm tired of fiddling
        const light2 = new THREE.AmbientLight( 0x404040 );
        viewer.scene.scene.add(light2);

        window.camera = viewer.scene.getActiveCamera();
        camera.near = 0; // Adjust this value to a smaller number to allow closer viewing
        camera.updateProjectionMatrix();
        
        //let pointLight = new THREE.PointLight( 0xffffff, 1000, 1000, 0 );

        //let spin = new THREE.

        /*

        let sph = new Potree.SpotLightHelper(light, new THREE.Color().setHex(0xff0000));
        viewer.scene.scene.add(sph);


        let cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256 );
        cubeRenderTarget.texture.type = THREE.HalfFloatType;

        let cubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );

        let material = new THREE.MeshStandardMaterial( {
            envMap: cubeRenderTarget.texture,
            roughness: 0.05,
            metalness: 1
        } );

        let sphere = new THREE.Mesh( new THREE.IcosahedronGeometry( 1, 8 ), material );
        viewer.scene.scene.add( sphere );


        const material2 = new THREE.MeshStandardMaterial( {
            roughness: 0.1,
            metalness: 0
        } );

        let cube = new THREE.Mesh( new THREE.BoxGeometry( 0.1, 0.1, 0.1 ), material2 );
        viewer.scene.scene.add( cube );

        let torus = new THREE.Mesh( new THREE.TorusKnotGeometry( 0.4, 0.2, 128, 16 ), material2 );
        viewer.scene.scene.add( torus );

        /*const controls = new THREE.DragControls( [torus,cube,sphere], viewer.scene.cameraO, viewer.renderer.domElement );

        // add event listener to highlight dragged objects

        controls.addEventListener( 'dragstart', function ( event ) {
            event.object.material.emissive.set( 0xaaaaaa );
        } );

        controls.addEventListener( 'dragend', function ( event ) {
            event.object.material.emissive.set( 0x000000 );
        } );*/
        function getColor(){ 
            return [ Math.random(),
                    (0.5 + 0.5 * Math.random()),
                    (0.5 + 0.5 * Math.random())]
        }
        
        function hslToRgb(h, s, l){
            var r, g, b;
        
            if(s == 0){
                r = g = b = l; // achromatic
            }else{
                var hue2rgb = function hue2rgb(p, q, t){
                    if(t < 0) t += 1;
                    if(t > 1) t -= 1;
                    if(t < 1/6) return p + (q - p) * 6 * t;
                    if(t < 1/2) return q;
                    if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                }
        
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
        
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
            
        function hslToHex(h, s, l) {
            var a = hslToRgb(h,s,l);
            return a[0]*(16**4) + a[1]*(16**2) + a[2]
            //return `#${f(0)}${f(8)}${f(4)}`;
        }


        window.highlight = function (which, callback){
            
            var ret = {}
            callback = callback || function(){};

            var material = new THREE.MeshDepthMaterial();
            material = new THREE.MeshStandardMaterial({
                emissive: 0x000000,
            });
            
            var c1 = getColor();
            var c2 = hslToRgb.apply(null, c1);
            var c3 = hslToHex.apply(null, c1);
            
            console.log( c1, c2, c3 );
            
            ret.color = c2;
            ret.name = which;
            
            material = new THREE.MeshPhongMaterial( { color: 0x000000, specular: 0x666666, emissive: c3, shininess: 0, opacity: 0.9, transparent: true,
                wireframe: true,
                wireframeLinewidth: 2 } );
                
            material = new THREE.MeshBasicMaterial({
                color: c3,
                wireframe: true,
                wireframeLinewidth: 10
            });

            function animate_flash(){
                const X = {op:1}
                var tw1 = new TWEEN.Tween(X)
                    .to({op:0}, 500)
                    .onUpdate(() => {
                        viewer.setEDLOpacity(X.op)
                        mesh.material.opacity = 1-X.op
                        console.log(mesh.material.opacity)
                    });
                var tw2 = new TWEEN.Tween(X)
                    .to({op:1}, 500)
                    .onUpdate(() => {
                        viewer.setEDLOpacity(X.op)
                        mesh.material.opacity = 1-X.op
                    });

                tw2.onComplete(function(){
                    viewer.scene.scene.remove(mesh);
                })

                tw1.chain(tw2).start();
            }

            function permanent_highlight(){
                const X = {op:viewer.edlOpacity}
                var tw1 = new TWEEN.Tween(X)
                    .to({op:0.8}, 500)
                    .onUpdate(() => {
                        viewer.setEDLOpacity(X.op)
                        mesh.material.opacity = 0.8
                    });

                tw1.start();
            }
            
            const loader = new STLLoader()
            var mesh;
            loader.load(
                `/data/field_meshes/${which}.stl`,
                function (geometry) {
                    mesh = new THREE.Mesh(geometry, material)
                    mesh.scale.set(100,100,100)
                    material.transparent = true;
                    viewer.scene.scene.add(mesh)
                    console.log('got it!', mesh)
                    
                    ret.mesh = mesh;
                    
                    permanent_highlight();
                    callback(ret);
                },
                (xhr) => {
                    console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
                },
                (error) => {
                    console.log(error)
                }
            )

        }

        window.pc = null;

        function setup_subfields() {
            var $l = $("#legend");
            $l.html("")
            var top_fields = Object.keys(window.subfields).sort();

            window.subfield_links = []
            for(var si in top_fields){ // top level fields
                var s = top_fields[si];
                var $myl = (function(S){
                    var $s;
                    $s = $("<span class='legend_item'>").click(function(){

                        if(pc != null){
                            pc.visible = false;
                        }

                        $(".legend_expansion").remove();

                        if(!$s.data('expanded')){							

                            load_field_potree(S, function(pc){
                                setTimeout(function(){
                                    main_pc.visible=false;

                                    if (false) {
                                        main_pc.material.opacity = 0.05;
                                        
                                        // saturate all colors in the point cloud
                                        pc.material.color.set(0.6,0.6,0.6);
                                    }
                                }, 1500);
                            });
                            
                            var $ls = $("<div class='legend_expansion'>");
                            for( var ji in window.subfields[S] ){
                                var sub = window.subfields[S][ji];
                                var c = window.subfield_colors[S][sub];
                                console.log(ji,sub,c);
                                //var rgb = `${256-c[2]*256}, ${256-c[0]*256}, ${256-c[1]*256}`;
                                var rgb = `${c[0]*256}, ${c[1]*256}, ${c[2]*256}`;
                                $ls.append(
                                    $(`<div class='swatch' style='background-color:rgb(${rgb})'>`),
                                    $("<div class='label'>").html(sub),
                                    $("<br>")
                                );
                                if( ji > 14 ) break;
                            }
                            
                            $ls.append(
                                $(`<div class='swatch' style='background-color:rgb(60,60,60)'>`),
                                $("<div class='label'>").html('Other'),
                                $("<br>")
                            );
                            $ls.insertAfter($s);
                            $(".legend_item").data('expanded', false);
                            $s.data('expanded', true);
                        } else {
                            main_pc.visible=true;
                            $s.data('expanded', false);
                        }
                    });
                    $s.data('expanded', false);
                    $s.html(S);
                    return $s;
                })(s);

                subfield_links.push($myl);
                $l.append( $myl )
            }
        };

        $(document).ready(function(){
            // Load field data from JSON
            $.getJSON('/data/fields.json', function(data) {
                window.fields = data.top_level;
                window.subfield_colors = data.subfield_colors;
                window.subfields = data.subfields;    
            }).then( setup_subfields );

            setup_subfields();
        });
    

        viewer.scene.view.position.set(28910, 74489, -6947);
        viewer.scene.view.lookAt(573.5842551496426, 450.36947654709786, 418.62651746203494);

        //var c = new Potree.Compass(viewer)
        //c.setVisible(true);
        //window.c = c;

        // we hide other modes until you get there
        $("#menu div").toggle(false);
        // $("#skip_intro").toggle(true);
        
        var intro_cancelled = false;
        
        function done_with_intro() {
            $("#prettier_game_info").html("");
            $("#menu div").toggle(true);
            $("#skip_intro").toggle(false);
            $("#tips_link").toggle(true);
            $("#comment_link").toggle(true);
        }
        
        function startPresentation() {
        
            $("#skip_intro").toggle(true);
        
            var squeue = [
                ['Changing our frame of reference invites us to explore what we know from new perspectives and angles.', 7],
                ['From the first space flight in the 1960s to observing an atom, shifting perspective allowed researchers to see what they know and what is still left to understand.', 10],
                ['Inspired by this, The Knowledge Cosmos collects 17 million research papers across disciplines and maps them into a 3D space.', 8],
                ['Our hope is that the vastness of how much knowledge is out there and how it intersects disciplines will inspire you to see where we have left to explore',9],
                ['as well as incite curiosity for disciplines you seek to learn about and find your own intersections.', 6],
                ["When we have an understanding of what we don't know, the possibilities of discovery then become limitless. ", 9],
                ['We invite you to explore', 3],
                ['END',8],
                
                ['To navigate around the COSMOS, use the Arrow Keys or WASD to move left, right, zoom in or out. Add the space bar to speed up movement in any of those directions.', 7],
                ['Click and drag to explore around. Double click to enter the cloud and propel forward in the cloud.', 6],
                ['When you enter the cloud, click on the Colored Dots to reveal Academic Paper Titles and Links.', 6]
            ]
            var squeue_old = [
                'before thought,',
                'before investigation,',
                'perhaps this is what it was like...',
                '',//16S
                'we\'re traveling somewhere,',
                'can you see it there in the distance?',
                'a swirling gas of human knowledge',
                '',//32S
                'this is cheesy...',
                "we've collected 17M academic papers",
                "and arranged them in 3D space, based on what they cite",
                '',//48S
                "you can use your spaceship to hunt around, explore, or perhaps",
                "just wonder at the magnitude of it all",
                "you can now use arrow keys or WASD to move",
                "click and drag to move around, spacebar to boost forward",
                "and double-click to warp",
            ];
            
            var T;
            T = function(){
                if(!squeue.length || intro_cancelled){clearInterval(T);
                    done_with_intro();
                }
                else{
                    var m = squeue.shift();
                    console.log(m)
                    
                    if(m[0]=='END'){//end
                        $("#prettier_game_info").html("THE KNOWLEDGE COSMOS").css({
                            'font-size': '80pt',
                            'font-family': 'cyber',
                            'max-width': '100%',
                            'width': '100%'
                        });
                    } else {
                        $("#prettier_game_info").html(m[0]).css({
                            'font-size': '',
                            'font-family': '',
                            'max-width': '',
                            'width': ''
                        });;
                    }
                    
                    setTimeout(T, m[1]*1000);
                    console.log( m[1]*1000 / m[0].length );
                }
            }
            T();
            
            // 1210, 1267, -364
            // start cruising towards the thing
            var loc={x:viewer.scene.view.position.x, y:viewer.scene.view.position.y, z:viewer.scene.view.position.z}
            
            console.log(TWEEN)
            
            window.Tstart = new TWEEN.Tween(loc)//1623, 1950, 1492
                .to({ x: 1623, y: 1950, z: 1492 }, 60000)
                .easing(TWEEN.Easing.Exponential.Out)
                .onUpdate(() => {
                    viewer.scene.view.position.set( loc.x, loc.y, loc.z );
                    viewer.scene.view.lookAt(730, 691, 725);
                })
                .onComplete(function(){
                    circle(19000);
                    viewer.setPointBudget(2_000_000);
                })
                .start();
        };

        //Potree.loadPointCloud(`../pointclouds/0TOP.las_converted/metadata.json`, "scimap", function(e){
        Potree.loadPointCloud(`/data/pointclouds/full/metadata.json`, "scimap", function(e){
        
            // we need to spin longer to wait for points to be loaded...
            var TT;
            TT = setInterval(function(){
                if(viewer.scene.pointclouds[0].visibleNodes.length > 0){
                    clearInterval(TT);
                    startPresentation();
                }
            }, 100);
            
            viewer.scene.addPointCloud(e.pointcloud);
            let material = e.pointcloud.material;
            
            viewer.setMoveSpeed( 2.5 );
            viewer.setFOV( 35 );
            viewer.setBackground('black')
    
            // I kind of like this aesthetic, but it causes a terrible flicker
            viewer.setEDLEnabled(false)
            viewer.setEDLRadius(1.1)
            viewer.setEDLStrength(0.1)

            window.main_pc = e.pointcloud;
            window.main_mat = material;

            // console.log(e.pointcloud, material);

            material.size = 0.08;
            material.minimumNodePixelSize = 2;
            material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
            material.shape = Potree.PointShape.CIRCLE;
            //material.activeAttributeName = "elevation";
            material.uniforms.uShadowColor.value = [0.6, 0.6, 0.6];
            
        })
        
        window.skip_intro = function() {
            Tstart.stop();
            intro_cancelled = true;
            
            var loc={x:viewer.scene.view.position.x, y:viewer.scene.view.position.y, z:viewer.scene.view.position.z}
            new TWEEN.Tween(loc)
                    .to({ x: 1623, y: 1950, z: 1492 }, 1000)
                    .onUpdate(() => {
                        viewer.scene.view.position.set( loc.x, loc.y, loc.z );
                        viewer.scene.view.lookAt(730, 691, 725);
                    })
                    .start();
                    
            
            done_with_intro()
            
            viewer.setPointBudget(2_000_000);
        }

        function load_field_potree(S, callback) {

                if(false){
                var X = {
                    gbc0: main_mat.uniforms.uRGB_gbc.value[0],
                    gbc1: main_mat.uniforms.uRGB_gbc.value[1],
                    gbc2: main_mat.uniforms.uRGB_gbc.value[2],
                    op: viewer.getEDLOpacity()
                }
                new TWEEN.Tween(X)
                        .to({gbc0:0, gbc1:-0.6, gbc2:0, op:0.5}, 500)
                        .onUpdate(() => {
                            // nice, fades the colors to the background
                            main_mat.uniforms.uRGB_gbc.value = [X.gbc0, X.gbc1, X.gbc2]
                            //viewer.setEDLOpacity(X.op)
                        })
                        .start();
                }
                

                //Potree.loadPointCloud("../pointclouds/scimap.las_converted/metadata.json", "scimap", function(e){
                Potree.loadPointCloud(`/data/pointclouds/${S}/metadata.json`, S, function(e){

                    viewer.scene.addPointCloud(e.pointcloud);
                    //e.pointcloud.position.z = 0;
                    let material = e.pointcloud.material;
                    //material.size = 0.42;
                    material.size = 0.04;
                    material.minimumNodePixelSize = 0;
                    material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
                    material.shape = Potree.PointShape.CIRCLE;
                    //material.activeAttributeName = "elevation";
                    material.uniforms.uShadowColor.value = [0.6, 0.6, 0.6];

                    window.pc = e.pointcloud

                    callback(e.pointcloud);

                    /*
                    const coords = viewer.scene.view.position.subScalar(0)
                    new TWEEN.Tween(coords)
                        .to(new THREE.Vector3(1551, 2120, 711), 5000)
                        .onUpdate(() => {
                            viewer.scene.view.position.set(coords.x, coords.y, coords.z);
                            viewer.scene.view.lookAt(578,502,263);
                        })
                        .start();
                    */

                    /*
                    forget this rotation magic. taken up too much time

                    */



                    //pointLight.position.set(415.005, 354.499, 371.803);
                    //pointLight.position.set(1,1,1);
                    //camera.add(pointLight);

                    /*
                    function light_update()
                    {
                        var p=camera.getWorldPosition();
                        light.position.copy( p );
                        light.lookAt( p+camera.getWorldDirection() );
                        console.log( light.position );
                    }

                    viewer.controls.addEventListener( 'change', light_update );
                    */
                });
        }		
        /*

        // Sigeom
        Potree.loadPointCloud("http://5.9.65.151/mschuetz/potree/resources/pointclouds/archpro/heidentor/cloud.js", "Heidentor", function(e){
            viewer.scene.addPointCloud(e.pointcloud);
            e.pointcloud.position.z = 0;
            let material = e.pointcloud.material;
            material.size = 1;
            material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
            material.activeAttributeName = "elevation";
            material.uniforms.uShadowColor.value = [0.6, 0.6, 0.6];

            viewer.scene.view.position.set(19.474, -14.324, 12.829);
            viewer.scene.view.lookAt(0.339, 0.145, 4.073);
        });

        
        Potree.loadPointCloud("../pointclouds/lion_takanawa/cloud.js", "lion", function(e){
            viewer.scene.addPointCloud(e.pointcloud);
            
            let material = e.pointcloud.material;
            material.size = 1;
            material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
            material.uniforms.uShadowColor.value = [0.6, 0.6, 0.6];
            
            e.pointcloud.position.set(0, -2, 0);
            
        });

        */

        viewer.mouse = null;

        $(document).on('mousemove', function(e){
            viewer.mouse = e.originalEvent;
        });
        
        $('canvas').on('mousedown', function(e){
            if(e.originalEvent.button == 0){ // left-click only
                check_and_display();
            }
        });
        
        window.multiplier = 1;

        $(document).on('keypress', function(e){
            if( e.originalEvent.charCode == 32 ) {
                multiplier *= 3
                setTimeout(function(){
                    multiplier /= 3;
                }, 1000)
            }
        });


        window.focal_sphere = null;
        window.focal_i = null;

        var cache = {}
        function get_data(i, callback) {
            if( cache[i] || cache[i]===null ) {
                callback(cache[i]);
                return;
            }

            // fetch and display the info
            $.ajax({
                "url": `https://api.semanticscholar.org/v1/paper/MAG:${i}`,
                "method": "GET",
                crossDomain: true,
                "success": function(resp){
                    if( resp.error ) {
                        cache[i] = null;
                    } else {
                        cache[i] = resp;
                    }
                    callback(cache[i]);
                }
            })
            
            if( false ) {
                $.ajax({
                    "url": `${BASE}/paper`,
                    "method": "GET",
                    crossDomain: true,
                    "data": {'id':''+i},
                    "success": function(resp){
                        if( resp == '0' )
                            cache[i] = null;
                        else
                            cache[i] = $.parseJSON( resp );

                        callback(cache[i]);
                    }
                });
            }
        }


        // simply did not work...
        // I couldn't figure out any of the octree apis...
        var loc_cache = [];
        window.loc_cache = loc_cache;
        var search_delt = 5;

        function findpoint(pt, delt){
            for(var li in loc_cache){
                var l = loc_cache[li][0];
                var data = loc_cache[li][1];
                if(
                    (l.x-delt < pt.x && pt.x < l.x+delt) &&
                    (l.y-delt < pt.y && pt.y < l.y+delt) &&
                    (l.z-delt < pt.z && pt.z < l.z+delt)
                ){
                    return {l:l, data:data};
                }
            }
            return null;
        }

        var last_ret = null;

        function search_area(x,y,z, callback){

            var pos = new THREE.Vector3(x,y,z);
            var nearest_query = findpoint({x:x,y:y,z:z},search_delt);
            if( nearest_query ){
                if( nearest_query.l != last_ret ){
                    callback(nearest_query.data);
                    last_ret = nearest_query.l
                }

                return
            }

            last_ret = pos;

            // fetch the info
            $.ajax({
                "url": `${BASE}/location`,
                "method": "GET",
                crossDomain: true,
                "data": {'x':x,'y':y,'z':z,'delt':15},
                "success": function(resp){
                    console.log('adding', x, y, z)
                    var resp = $.parseJSON( resp )
                    loc_cache.push([
                        {x:x,y:y,z:z},
                        resp
                    ]);
                    callback(resp);					
                }
            });

        }

        /*
        var locs = [];
        function make_floating_text(l){
            var $lab = $("<div class='floating_text'>");
            $lab.data('coords', {x:l.x, y:l.y, z:l.z});
            
            $lab.html(l.js.title);

            $("#labels").append($lab);
            locs.push($lab);
        }

        var queue = [];

        function chunk_queue(){
            if(!queue.length){
                $("#reporting").html("")
                return;
            }
            var el = queue.pop();
            
            if( el.js.journal )
                var link = `<a target='_blank' href='https://doi.org/${el.js.journal}'>link</a>`
            else
                var link = ''

            $("#reporting").html(`Now passing ${el.js.title}, published ${el.js.year} ${link}`)
        }

        setInterval(chunk_queue, 4000);

        // query every now and then to find points that should be clickable, and put halos around them
        function check(){
            var p = camera.position;
            search_area(p.x,p.y,p.z, function(resp){
                if(false){
                    // remove old ones
                    for(var li in locs){
                        var l = locs[li];
                        l.remove();
                    }
                    locs = [];
                }
                queue = [];

                for( var li in resp ) {
                    queue.push(resp[li]);
                }
            })
        }

        setInterval(check, 3000);
        check();
        */

        if(false){
            // simply did not work...
            // I couldn't figure out any of the octree apis...
            var loc_cache = [];

            // my first spatial query
            //window.query_points = new d3.octree();
            
            
            var search_delt = 500;

            function search_area(x,y,z, callback){

                var pos = new THREE.Vector3(x,y,z);
                var nearest_query = query_points.find({x:x,y:y,z:z},search_delt);
                if( nearest_query ){
                    return nearest_query;
                }
                console.log(nearest_query)

                // fetch the info
                $.ajax({
                    "url": `${BASE}/location`,
                    "method": "GET",
                    crossDomain: true,
                    "data": {'x':x,'y':y,'z':z,'delt':15},
                    "success": function(resp){
                        console.log('adding', x, y, z)
                        var resp = $.parseJSON( resp );
                        query_points.add((x,y,z,resp));
                        callback(resp);
                    }
                });
            }

            // query every now and then to find points that should be clickable, and put halos around them
            setInterval(function(){
                var p = camera.position;
                search_area(p.x,p.y,p.z, function(resp){
                    for( var LOC in resp ) {
                        make_floating_text(LOC)
                    }
                })
            }, 10000);
        }

        /*
        window.getAllPointsOfPointCloud = function() {
            var list = [];
            var array = pc.pcoGeometry.root.geometry.attributes.position.array;
            var index = 0;
            for (var i = 0; i < pc.pcoGeometry.root.geometry.attributes.position.length;i=i+3) {
                var x = array[i + 0];
                var y = array[i+ 1];
                var z = array[i + 2];
                let position = new THREE.Vector3(x, y, z);
                position.applyMatrix4(pc.matrixWorld);
                list[index] = position;
                index++;
            }
            return list;
        }
        */
        var w = window.innerWidth, h = window.innerHeight;

        function getScreenPosition(vector) {
            var canvas = viewer.renderer.domElement;

            // map to normalized device coordinate (NDC) space
            vector.project( camera );

            // console.log(vector)
            
            // map to 2D screen space
            vector.x = Math.round( (   vector.x + 1 ) * canvas.width  / 2 );
            vector.y = Math.round( ( - vector.y + 1 ) * canvas.height / 2 );
            vector.z = 0;

            //console.log(vector);

            // console.log(vector)

            return { 
                x: vector.x,
                y: vector.y
            };
        };
        
        window.check_and_display = function() {
        
        
            function killSphere(){
                if( focal_sphere ) {
                    viewer.scene.scene.remove(focal_sphere);
                }
                focal_sphere = null;
                focal_i = null;
            }
            
        
            if(viewer.mouse){
              // copy the mouse position into a new object
              
              const e = viewer.mouse
              let m = viewer.mouse

              if($(".card").is(":visible")) {
                // shift all positions by 400px
                m = new MouseEvent("click", {
                  bubbles: true,
                  cancelable: true,
                  view: window,
                  screenX: e.screenX - 400,
                  screenY: e.screenY,
                  clientX: e.clientX - 400,
                  clientY: e.clientY,
                  pageX: e.pageX - 400,
                  pageY: e.pageY,
                  button: e.button,
                  buttons: e.buttons,
                  relatedTarget: e.relatedTarget,
                  ctrlKey: e.ctrlKey,
                  shiftKey: e.shiftKey,
                  altKey: e.altKey,
                  metaKey: e.metaKey,
                });
              }

                let I = Potree.Utils.getMousePointCloudIntersection(
                    m,
                    camera,
                    viewer,
                    viewer.scene.pointclouds);

                if (I !== null) {

                    
                    // only instantiate a new one if it's changed etc.
                    var myi = I.point['mag_id'][0];
                    if( (focal_i != myi) ){

                        if (I.distance < 50){
                            // smoothly move the camera to a fixed distance from the point
                            var currentDeltVector = camera.position.clone().sub(I.location);
                            var direction = currentDeltVector.normalize();

                            const delt = 8;
                            
                            var targetPosition = I.location.clone().add(direction.multiplyScalar(delt));
                            var targetLookAt = I.location.clone();
                            
                            // Save the camera's current position and orientation:
                            const startPosition = camera.position.clone();
                            const startQuaternion = camera.quaternion.clone();

                            // To tween the camera's orientation, we need to compute the target quaternion.
                            // We do this by creating a temporary matrix that "looks at" the target:
                            const m = new THREE.Matrix4();
                            const upsave = camera.up.clone();
                            console.log(upsave);
                            m.lookAt(targetPosition, targetLookAt, camera.up);

                            const targetQuaternion = new THREE.Quaternion().setFromRotationMatrix(m);

                            // Define the duration (in milliseconds) for the tween:
                            const duration = 2000; // 2 seconds

                            // We'll use an object with a parameter "t" that goes from 0 to 1 for interpolation.
                            const tweenObj = { t: 0 };

                            // Create the tween:
                            new TWEEN.Tween(tweenObj)
                            .to({ t: 1 }, duration)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .onUpdate(() => {
                                // Interpolate the position:
                                camera.position.lerpVectors(startPosition, targetPosition, tweenObj.t);

                                // Interpolate the orientation using quaternion slerp:
                                THREE.Quaternion.slerp(startQuaternion, targetQuaternion, camera.quaternion, tweenObj.t);

                                // set viewer.scene.view.position and viewer.scene.view.quaternion
                                viewer.scene.view.position.set( camera.position.x, camera.position.y, camera.position.z );
                            })
                            .onComplete(() => {
                                viewer.scene.view.position.set( camera.position.x, camera.position.y, camera.position.z );
                                viewer.scene.view.lookAt( targetLookAt );
                            })
                            .start();

                            killSphere();// because we'll make a new one

                            var sphere_geometry = new THREE.SphereGeometry(1, 128, 128);
                            var material = new THREE.MeshNormalMaterial();

                            focal_sphere = new THREE.Mesh(sphere_geometry, material);
                            focal_sphere.position.set( I.location.x, I.location.y, I.location.z );
                            focal_sphere.scale.set( 0.15, 0.15, 0.15 )
                            focal_sphere.frustumCulled = false;

                            viewer.scene.scene.add( focal_sphere );

                            focal_i = myi // keep track of the focal ID

                            $("#potree_render_area").css('left', '400px');
                            $(".card").toggle(true)
                            $(".card .loading-placeholders").show()
                            $(".card>.title, .card>.meta, .card>.tags, .card>.content").hide()

                            get_data(focal_i, function(resp){
                                
                                if( resp['doi'] )
                                    var link = `<a target='_blank' href='https://doi.org/${resp["doi"]}'>Link to Publisher</a>`
                                else
                                    var link = ''
                                        
                                if(false) {
                                    if( resp===null ){
                                        $("#paper_info").html(`
                                            no info found for this paper
                                        `)
                                    } else {

                                        $("#paper_info").html(`
                                            Selected Paper: 
                                            ${resp['title']} ${link} 
                                        `)
                                    }

                                    $("#paper_info").toggle(true)
                                }

                                $(".card .loading-placeholders").hide()
                                $(".card>.title, .card>.meta, .card>.tags, .card>.content").show()
                                
                                $(".card>.title").html(resp['title'])
                                $(".card>.meta").html(
                                    `${resp['year']} <br/>`
                                    + `${resp['venue']} <br/>`
                                    + `${resp['authors'].map((x) => x.name).join(', ')} <br/>`
                                    + `${link} <br/>`
                                )
                                $(".card>.content").html(resp['abstract'])
                                $(".card>.tags").html("");

                                const fields = [...new Set(resp['s2FieldsOfStudy'].map((x) => x.category))];
                                for( var field of fields ){
                                    $(".card>.tags").append(
                                        $("<span class='tag'>").html(field)
                                    )
                                }
                            });
                        } else {
                            // too far
                            killSphere();
                            $("#paper_info").toggle(false)
                            $(".card").toggle(false);
                            $("#potree_render_area").css('left', '0');
                            // this has been killing me...
                        }
                    } else { 
                        //repeat
                    }
                } else {
                    killSphere();
                    $("#paper_info").toggle(false)
                    $(".card").toggle(false);
                    $("#potree_render_area").css('left', '0');
                }
            } 
        }
        
        function changeSpeed(){
            /*
            var x = viewer.renderer.domElement.clientWidth / 2;
            var y = viewer.renderer.domElement.clientHeight / 2;
            
            var m = {x:x, y:y};
            
            let domElement = viewer.renderer.domElement;
            let ray = Utils.mouseToRay(m, camera, domElement.clientWidth, domElement.clientHeight);

            let nodes = main_pc.nodesOnRay(main_pc.visibleNodes, ray);
            let lastNode = nodes[nodes.length - 1];
            
            let sp = lastNode.getBoundingSphere(new THREE.Sphere());
            
            //console.log(sp.center, 000, camera.position, sp);
            var distance = sp.center.distanceTo( camera.position )
            */

            if (main_pc === null) {
                return;
            }
            
            var distance = main_pc.boundingSphere.center.distanceTo( camera.position );
            distance = Math.max( 0, distance - main_pc.boundingSphere.radius / 2 );
            var speed = Math.min( 30000, (3 + distance / 2) * multiplier );
            
            //console.log(distance, speed);
            viewer.setMoveSpeed( speed ); 
        }
        
        setInterval(changeSpeed, 100);


        async function in_frame(){


            /*
            for( var li in locs ){
                var l = locs[li];
                var pos = l.data('coords');
                var p = getScreenPosition( new THREE.Vector3(pos.x, pos.y, pos.z) );

                l.css({left: p.x, top: p.y});
            }
            */

/*
            let targetRadius = 0;
            {
                let minimumJumpDistance = 0.2;

                let domElement = this.renderer.domElement;
                let ray = Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);

                let nodes = I.pointcloud.nodesOnRay(I.pointcloud.visibleNodes, ray);
                let lastNode = nodes[nodes.length - 1];
                let radius = lastNode.getBoundingSphere(new THREE.Sphere()).radius;
                targetRadius = Math.min(this.scene.view.radius, radius);
                targetRadius = Math.max(minimumJumpDistance, targetRadius);
            }


            for( var X in e.pointcloud.visibleNodes ) {
                for( var Y in X.sceneNode.children ) {
                    let sphere = new THREE.Mesh( new THREE.IcosahedronGeometry( 1, 8 ), material );
                    sphere.position.set( Y.position );
                    console.log(Y.position)
                    viewer.scene.scene.add( sphere );
                }
            }

            console.log( e.pointcloud );
            console.log( e.pointcloud.visibleNodes );
            */

            //pointLight.updateMatrix();
            /*
            if(focal_sphere){
                focal_sphere.updateMatrixWorld()
            }
            */

            let coords = `Coordinates: ${Math.round(camera.position.x)}, ${Math.round(camera.position.y)}, ${Math.round(camera.position.z)}`
            //let lookat = `Looking At: ${Math.round(camera.position.x)}, ${Math.round(camera.position.y)}, ${Math.round(camera.position.z)}`
            var h = `
                Welcome to the game. I'm thinking now about some tour around this beautiful beast.<br>
                <div class='smaller'>
                ${coords}<br/>
                Speed: ${Math.round(viewer.getMoveSpeed())}
                </div>
            `

            if( h != last_h ) {
                $("#game_info .ephemeral").html( h );
                last_h = h;
            }
        }

        var li = 0;
        function loop(timestamp){
            viewer.update(viewer.clock.getDelta(), timestamp);

            if( (li%10)==0 )
                in_frame()

            if( focal_sphere ) {

                var time = performance.now() * 0.003;
                
                // change 'k' value for more spikes
                var k = 3;
                for (var i = 0; i < focal_sphere.geometry.vertices.length; i++) {
                    var p = focal_sphere.geometry.vertices[i];
                    p.normalize().multiplyScalar(1 + 0.3 * noise.perlin3(p.x * k + time, p.y * k + time, p.z * k));
                }
                focal_sphere.geometry.computeVertexNormals();
                focal_sphere.geometry.normalsNeedUpdate = true;
                focal_sphere.geometry.verticesNeedUpdate = true;

            }
            
            // update speed so it is faster as you are further away
            //viewer.setMoveSpeed( camera.position.sub( b ).length() );


            viewer.renderer.render(viewer.scene.scene, camera)
            viewer.render();
            li += 1;
            
            setTimeout(function(){
                requestAnimationFrame(loop);
            }, 1000/25);
        }

        window.last_h = null;

        requestAnimationFrame(loop);

        window.anim = null;

        window.home = function(){

            var Y = {
                x:viewer.scene.view.position.x,
                y:viewer.scene.view.position.y,
                z:viewer.scene.view.position.z,
                lx:730,ly:691,lz:725
            }

            var view_update = () => {
                viewer.scene.view.position.set(Y.x,Y.y,Y.z);
                viewer.scene.view.lookAt(Y.lx,Y.ly,Y.lz);
            }
            
            var Trans1 = new TWEEN.Tween(Y)
                .onUpdate(view_update)
                .to({x:1623, y:1950, z:1492}, 1000).start();
            anim = Trans1

        }

        window.circle = function(delay) {

            
            // current position for reference
            var a = new THREE.Vector3(viewer.scene.view.position.x, viewer.scene.view.position.y, viewer.scene.view.position.z);

            // target focal point
            var b = new THREE.Vector3(730, 691, 725);

            // current approximate focal point 
            var d = new THREE.Vector3();
            camera.getWorldDirection(d);

            var c = b.clone().sub(a).projectOnVector( d );
            var e = a.clone().add(c);
            
            var X = {angle:0, lk0:e.x, lk1:e.y, lk2:e.z};

            var Rot1 = new TWEEN.Tween(X)
                .to({angle: 2 * Math.PI,
                    lk0:b.x, lk1:b.y, lk2:b.z}, delay||5000)
                .onUpdate(() => {
                    var curlit = a.clone().sub(b);
                    curlit.applyAxisAngle( camera.up, X.angle );
                    var result = b.clone().add( curlit );
                    
                    viewer.scene.view.position.set(result.x, result.y, result.z);
                    //viewer.scene.view.lookAt(X.lk0, X.lk1, X.lk2);
                    viewer.scene.view.lookAt(730, 691, 725);
                });
            Rot1.start();
            anim = Rot1;

        }

        window.tour = function() {
            // current position for reference
            var a = new THREE.Vector3(viewer.scene.view.position.x, viewer.scene.view.position.y, viewer.scene.view.position.z);

            // target focal point
            var b = new THREE.Vector3(400,400,200);

            // current approximate focal point 
            var d = new THREE.Vector3();
            camera.getWorldDirection(d);

            var c = b.clone().sub(a).projectOnVector( d );
            var e = a.clone().add(c);
            
            var Y = {
                x:viewer.scene.view.position.x,
                y:viewer.scene.view.position.y,
                z:viewer.scene.view.position.z,
                lk0:e.x, lk1:e.y, lk2:e.z
            }

            var target = {x:584, y:866, z:358, lk0:400,lk1:400,lk2:200}

            var view_update = () => {
                viewer.scene.view.position.set(Y.x,Y.y,Y.z);
                viewer.scene.view.lookAt(Y.lk0,Y.lk1,Y.lk2);
            }
            
            var Trans1 = new TWEEN.Tween(Y)
                .onUpdate(view_update)
                .to(target, 1000).start();

            anim = Trans1;
        }

        window.stop = function() {
            anim.stop();
        }

        window.brain = function() {
            let volume = new Potree.ClipVolume(camera);
            let m0 = new THREE.Mesh();
            let m1 = new THREE.Mesh();
            let m2 = new THREE.Mesh();
            let m3 = new THREE.Mesh();
            m0.position.set(-1, -1, 0);
            m1.position.set( 1, -1, 0);
            m2.position.set( 1,  1, 0);
            m3.position.set(-1,  1, 0);
            volume.markers.push(m0, m1, m2, m3);
            volume.
            volume.initialized = true;
            
            viewer.scene.addPolygonClipVolume(volume);
        }
        
        window.field_mode = function() {
            $(".right_boy").toggle(false);
            $("#legend").toggle(true);
        }
        
        window.constellation = function() {
            $(".right_boy").toggle(false);
            $("#constellation").toggle(true);
            //var what = prompt("Enter a field to add its constellation to the map, e.g. 'Sociology'");
            //highlight(what);
        }
        
        $("#constellation #field_lookup").autocomplete({source:fields});
        $("#constellation #field_add").click(function(){
            highlight( $("#field_lookup").val(), function(ret){
                var c = ret.color;
                
                var $item = $("<div class='legend_item'>");
                
                var $r_link = $("<div class='link'>remove</a>").click(function(){
                    viewer.scene.scene.remove(ret.mesh);
                    $item.remove();
                });
                
                $item.append(
                    $(`<svg height="25" width="25" style="stroke:rgb(${c[0]},${c[1]},${c[2]}); stroke-width:2px;">
                        <polygon points="12.5,3 5,20 20,20" class="triangle" />
                    </svg>`),
                    $(`<span class='lab'>${ret.name}</span>`),
                    $r_link
                );
                
                $("#const_legend").append($item);
            })
        })
        
        $("#menu .title").click(home);

        
  document.addEventListener('DOMContentLoaded', function() {
      const toolbarItems = document.querySelectorAll('.toolbar-item[data-selectable="true"]');
      const toggleSwitch = document.querySelector('.toggle-switch');
      let isRectSelectActive = false;
      let isDrawing = false;
      let startX, startY;
      let selectionRect = null;
      let isOrthographicMode = false;

      // Add camera mode toggle functionality
      toggleSwitch.addEventListener('click', function() {
          isOrthographicMode = !isOrthographicMode;
          this.classList.toggle('active');
          
          if (isOrthographicMode) {
              viewer.setCameraMode(Potree.CameraMode.ORTHOGRAPHIC);
          } else {
              viewer.setCameraMode(Potree.CameraMode.PERSPECTIVE);
          }
      });

      // Rest of the existing code...

      // Create selection rectangle element
      const rect = document.createElement('div');
      rect.style.position = 'absolute';
      rect.style.border = '2px solid #00ff00';
      rect.style.backgroundColor = 'rgba(0, 255, 0, 0.1)';
      rect.style.display = 'none';
      rect.style.pointerEvents = 'none';
      rect.style.zIndex = '1000';
      document.body.appendChild(rect);

      toolbarItems.forEach(item => {
          item.addEventListener('click', function() {
              toolbarItems.forEach(item => item.classList.remove('selected'));
              this.classList.toggle('selected');
              
              // Handle rectangle select tool
              if (this.id === 'rect-select') {
                  isRectSelectActive = this.classList.contains('selected');
                  if (!isRectSelectActive) {
                      rect.style.display = 'none';
                      // Re-enable viewer controls
                      viewer.fpControls.enabled = true;
                      viewer.orbitControls.enabled = true;
                  } else {
                      // Disable viewer controls
                      viewer.fpControls.enabled = false;
                      viewer.orbitControls.enabled = false;

                      // unbind listeners
                      // Unbind rectangle selection event listeners
                      document.removeEventListener('mousedown', window.rect_mdlistener);
                      document.removeEventListener('mousemove', window.rect_mmlistener); 
                      document.removeEventListener('mouseup', window.rect_mulistener);
                  }
              }
          });
      });

      // Mouse event handlers for rectangle selection
      window.rect_mdlistener = function(e) {
          if (!isRectSelectActive) return;
          
          isDrawing = true;
          startX = e.clientX;
          startY = e.clientY;
          
          rect.style.display = 'block';
          rect.style.left = startX + 'px';
          rect.style.top = startY + 'px';
          rect.style.width = '0';
          rect.style.height = '0';
      };

      window.rect_mmlistener = function(e) {
          if (!isDrawing) return;
          
          const currentX = e.clientX;
          const currentY = e.clientY;
          
          const width = Math.abs(currentX - startX);
          const height = Math.abs(currentY - startY);
          const left = Math.min(startX, currentX);
          const top = Math.min(startY, currentY);
          
          rect.style.width = width + 'px';
          rect.style.height = height + 'px';
          rect.style.left = left + 'px';
          rect.style.top = top + 'px';
      };

      window.rect_mulistener = function(e) {
          if (!isDrawing) return;
          
          isDrawing = false;
          const width = Math.abs(e.clientX - startX);
          const height = Math.abs(e.clientY - startY);
          
          // Only trigger if the selection is significant enough
          if (width > 10 && height > 10) {
              // Calculate the center point of the selection
              const centerX = Math.min(startX, e.clientX) + width/2;
              const centerY = Math.min(startY, e.clientY) + height/2;
              
              // Call our zoom function with the selection coordinates
              zoomToSelection(centerX, centerY, width, height);
          }
          
          rect.style.display = 'none';
      };

      // Add the event listeners
      document.addEventListener('mousedown', window.rect_mdlistener);
      document.addEventListener('mousemove', window.rect_mmlistener);
      document.addEventListener('mouseup', window.rect_mulistener);

      function zoomToSelection(centerX, centerY, width, height) {
          // Convert screen coordinates to normalized device coordinates (-1 to 1)
          const ndcX = (centerX / window.innerWidth) * 2 - 1;
          const ndcY = -(centerY / window.innerHeight) * 2 + 1;
          
          // Create a point in 3D space
          const vector = new THREE.Vector3(ndcX, ndcY, 0.5);
          vector.unproject(camera);
          
          // Get the direction vector from camera to the point
          const direction = vector.sub(camera.position).normalize();
          
          // Calculate the distance based on the selection size and field of view
          const fov = camera.fov * (Math.PI / 180); // Convert FOV to radians
          const aspectRatio = window.innerWidth / window.innerHeight;
          
          // Calculate the height of the view frustum at the target distance
          // This is based on the camera's field of view and aspect ratio
          const frustumHeight = 2 * Math.tan(fov / 2);
          const frustumWidth = frustumHeight * aspectRatio;
          
          // Calculate how much of the view frustum our selection should take up
          // We want the selection to take up about 40% of the view
          const targetHeightRatio = 0.4;
          
          // Calculate the distance needed to make the selection the desired size
          // This is based on similar triangles: selectionHeight/distance = frustumHeight/1
          const distance = (Math.max(width, height) / window.innerHeight) / (frustumHeight * targetHeightRatio);
          
          // Calculate target position
          const targetPosition = camera.position.clone().add(direction.multiplyScalar(distance));
          
          // Calculate the target look-at point (center of selection)
          const lookAtPoint = new THREE.Vector3(ndcX, ndcY, 0);
          lookAtPoint.unproject(camera);
          
          // Create animation object with all values we want to animate
          const Y = {
              x: viewer.scene.view.position.x,
              y: viewer.scene.view.position.y,
              z: viewer.scene.view.position.z,
              lx: lookAtPoint.x,
              ly: lookAtPoint.y,
              lz: lookAtPoint.z
          };
          
          // Create target values
          const target = {
              x: targetPosition.x,
              y: targetPosition.y,
              z: targetPosition.z,
              lx: lookAtPoint.x,
              ly: lookAtPoint.y,
              lz: lookAtPoint.z
          };
          
          // Animate camera movement and rotation
          new TWEEN.Tween(Y)
              .to(target, 1000)
              .easing(TWEEN.Easing.Quadratic.Out)
              .onUpdate(() => {
                  // Update both camera and viewer scene view
                  camera.position.set(Y.x, Y.y, Y.z);
                  viewer.scene.view.position.set(Y.x, Y.y, Y.z);
                  viewer.scene.view.lookAt(Y.lx, Y.ly, Y.lz);
              })
              .onComplete(() => {
                  // Re-enable viewer controls
                  viewer.fpControls.enabled = true;
                  viewer.orbitControls.enabled = true;
              })
              .start();
      }
  });
        
    </script>


<div class="card" style='display: none;'>
    <div class="title"></div>
    <div class="meta"></div>
    <div class="tags"></div>
    <div class="content"></div>
    <div class="loading-placeholders" style="display: none;">
        <div class="loading-placeholder title"></div>
        <div class="loading-placeholder meta"></div>
        <div class="loading-placeholder tags"></div>
        <div class="loading-placeholder content"></div>
    </div>
</div>

<div id="game_info" style='display:none;'>
    <div class='ephemeral'>This is only a game.	</div>
    <div class='always'>
        <a href='#' onclick='javascript:home();'>Home</a>, <a href='javascript:circle();'>Circle</a>, <a href='javascript:tour();'>Tour</a>,
        <a href='#' onclick='javascript:brain();'>Brain Scan</a>
        <br/><a href='javascript:stop();'>Stop All</a>
    </div>
</div>

<div id="prettier_game_info">
    Loading...
</div>
<div id="paper_info" style='display:none'></div>
<!--<div style='
    border-radius: 15px;
    overflow: hidden;
    width: 320px;
    float: right;
    margin-right: 22px;
    max-height: calc(100% - 60px);
'>-->
    <div id="legend" class='right_boy' style='display:none; margin-right:0; margin-top:15px;'></div>
<!--</div>-->
<div id="constellation" class='right_boy' style='display:none;'>
    <p>
        Specify an academic field to show its constellation in the map.
        This constellation shows the approximate bounds of where papers in the field are located.
        This can be used along with <i>filter</i> to explore intersections and interactions between fields.
    </p>
    <input id='field_lookup' placeholder='Enter an academic field'/>
    <button id='field_add'>Add Constellation</button>
    <span id='field_bug' style='display:none;'></span>
    <div id='const_legend'></div>
</div>

<div id="reporting" style='display:none;'></div>
<div id="labels"></div>
<div id="menu">
    <div class='title' style='display:none; text-shadow: 
        -1px -1px 2px black,
        1px -1px 2px black,
        -1px 1px 2px black,
        1px 1px 2px black,
        2px 2px 2px black,
        -2px -2px 2px black,
        2px -2px 2px black,
        -2px 2px 2px black,
        3px 3px 2px black,
        -3px -3px 2px black'>The Knowledge Cosmos</div>
    <div class='item' id='skip_intro' onclick='skip_intro();' style='display:none'>Skip Intro</div>
    <div class='item' id='field_mode' onclick='field_mode();' style='display:none'>Filters</div>
    <div class='item' id='constellations' onclick='constellation();' style='display:none'>Constellations</div>
</div>


<div class="toolbar">
  <div class="toolbar-item selected" data-selectable="true" id="flight-control">
      <i class="fas fa-rocket"></i>
  </div>
  <div class="toolbar-item" data-selectable="true" id="orbit-control">
      <i class="fas fa-sync-alt"></i>
  </div>
  <div class="toolbar-item" data-selectable="true" id="rect-select">
      <i class="fas fa-vector-square"></i>
  </div>
</div>


<script>
</script>

<style>
.title {
    font-family: cyber;
    display: inline-block;
    font-size: 14pt;
    margin-right: 20px;
}
    #tips_close, #comments_close, #tips_next{
        cursor: pointer;
        text-decoration: underline;
    }
    #tips{
        text-align:left;
    }
</style>

<style>

/* updating to black style swatches*/
.swatch {
    width: 15px;
    height: 15px;
    display: inline-block;
    margin-right: 6px;
    border-radius: 8px;
}

.legend_expansion {
    background-color: black;
    color: white;
    padding: 10px;
    border-radius: 15px;
    margin-top: 5px;
    margin-bottom: 10px;
}

/*
    // swatches which touch space
    .swatch {
        width: 26px;
        height: 12px;
        display: inline-block;
        margin-right: 6px;
        border: 6px solid black;
        margin-left: -16px;
    }
    .label {
        display: inline-block;
        vertical-align: top;
        margin-top: 3px;
    }
*/
</style>

<div id="tips_link" class='linky' style='display:none;'>Tips</div>
<div id="comment_link" class='linky' style='display:none;'>Comments</div>

<div id="tips">
    <p class='focused'>Navigation: Use the Left and Right Arrow Keys to move left and right. 
        Use the Up and Down Arrow Keys to move forward and backwards. 
        Use R and F to move the ship up and down
    </p>
    <p>
        Use the Space Bar to boost forward. 
        Click and Drag to explore around. 
    </p>
    <p>
        Double click to enter the cloud and propel forward in the cloud. 
        To exit the cloud, Press "S" or Down Key and the Space Bar to boost
    </p>
    <p>Colored Dots: Click on the colored dots to reveal academic paper titles and links.</p>
    <p>Filter: Add a filter to specify the discipline you want to focus on exploring.</p>
    <p>Constellation: Select and layer constellations to see how disciplines intersect. 
        Combine filter tool and constellation to explore papers and the intersection of multiple disciplines.</p>
    <p>
        Click on 'The Knowledge Cosmos' to return to your first view of the cloud.
    </p>
    <span id="tips_next">Next</span>
    <span id="tips_close">Close</span>
</div>

<div id='comment_box' style="display:none; position: absolute;z-index: 3;background-color: white;padding: 15px;border-radius: 15px;left: 22px;bottom: 22px;width: 300px;">
    <!-- begin wwww.htmlcommentbox.com -->
    <div id="HCB_comment_box"><a href="http://www.htmlcommentbox.com">Comment Form</a> is loading comments...</div>
    <div id='comments_close'>Close</div>
    <link rel="stylesheet" type="text/css" href="https://www.htmlcommentbox.com/static/skins/bootstrap/twitter-bootstrap.css?v=0">
    <script type="text/javascript" id="hcb"> if(!window.hcb_user){hcb_user={};} (function(){var s=document.createElement("script"), l=hcb_user.PAGE || (""+window.location).replace(/'/g,"%27"), h="https://www.htmlcommentbox.com";s.setAttribute("type","text/javascript");s.setAttribute("src", h+"/jread?page="+encodeURIComponent(l).replace("+","%2B")+"&opts=16798&num=10&ts=1670172601141");if (typeof s!="undefined") document.getElementsByTagName("head")[0].appendChild(s);})(); </script>
<!-- end www.htmlcommentbox.com -->
</div>

<style>

#HCB_comment_box a {
    display: none;
}
.home-desc {
    display: none !important;
}

#tips p {
    display: none;
}
#tips p.focused {
    display: block;
}
</style>

<script>
    var nextT;
    
    function nexttip(){
        var current = $("#tips p.focused");
        var next = current.next();
        if(next.prop('tagName') == 'SPAN'){
            next = $("#tips p").first();
        }
        
        current.toggleClass('focused', false);
        next.toggleClass('focused', true);
        
        console.log(current, next)
        
        clearTimeout(nextT);
        nextT = setTimeout(nexttip, 5000);
    }

    nextT = setTimeout(nexttip, 5000);
    
    $("#tips_link, #tips_close").click(function(){
        $("#tips").toggle();
    })
    
    $("#comment_link, #comments_close").click(function(){
        $("#comment_box").toggle();
    })
    
    $("#tips_next").click(nexttip);
</script>

    </body>
</html>
